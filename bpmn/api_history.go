
/*
 * Flowable REST API
 *
 * # flowable / flowəb(ə)l /    - a compact and highly efficient workflow and Business Process Management (BPM) platform for developers, system admins and business users.  - a lightning fast, tried and tested BPMN 2 process engine written in Java. It is Apache 2.0 licensed open source, with a committed community.  - can run embedded in a Java application, or as a service on a server, a cluster, and in the cloud. It integrates perfectly with Spring. With a rich Java and REST API, it is the ideal engine for orchestrating human or system activities.
 *
 * API version: v1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package bpmn

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type HistoryApiService service
/*
HistoryApiService Get the binary data for a historic detail variable
The response body contains the binary value of the variable. When the variable is of type binary, the content-type of the response is set to application/octet-stream, regardless of the content of the variable or the request accept-type header. In case of serializable, application/x-java-serialized-object is used as content-type.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param detailId
@return []string
*/
func (a *HistoryApiService) GetHistoricDetailVariableData(ctx context.Context, detailId string) ([]string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/history/historic-detail/{detailId}/data"
	localVarPath = strings.Replace(localVarPath, "{"+"detailId"+"}", fmt.Sprintf("%v", detailId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryApiService Get the binary data for a historic task instance variable
The response body contains the binary value of the variable. When the variable is of type binary, the content-type of the response is set to application/octet-stream, regardless of the content of the variable or the request accept-type header. In case of serializable, application/x-java-serialized-object is used as content-type.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param varInstanceId
@return []string
*/
func (a *HistoryApiService) GetHistoricInstanceVariableData(ctx context.Context, varInstanceId string) ([]string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/history/historic-variable-instances/{varInstanceId}/data"
	localVarPath = strings.Replace(localVarPath, "{"+"varInstanceId"+"}", fmt.Sprintf("%v", varInstanceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryApiService Get the binary data for a historic task instance variable
The response body contains the binary value of the variable. When the variable is of type binary, the content-type of the response is set to application/octet-stream, regardless of the content of the variable or the request accept-type header. In case of serializable, application/x-java-serialized-object is used as content-type.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taskId
 * @param variableName
 * @param optional nil or *HistoryApiGetHistoricTaskInstanceVariableDataOpts - Optional Parameters:
     * @param "Scope" (optional.String) - 
@return []string
*/

type HistoryApiGetHistoricTaskInstanceVariableDataOpts struct {
    Scope optional.String
}

func (a *HistoryApiService) GetHistoricTaskInstanceVariableData(ctx context.Context, taskId string, variableName string, localVarOptionals *HistoryApiGetHistoricTaskInstanceVariableDataOpts) ([]string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/history/historic-task-instances/{taskId}/variables/{variableName}/data"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", fmt.Sprintf("%v", taskId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variableName"+"}", fmt.Sprintf("%v", variableName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Scope.IsSet() {
		localVarQueryParams.Add("scope", parameterToString(localVarOptionals.Scope.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryApiService List activity instances
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *HistoryApiListActivityInstancesOpts - Optional Parameters:
     * @param "ActivityId" (optional.String) -  An id of the activity instance.
     * @param "ActivityInstanceId" (optional.String) -  An id of the activity instance.
     * @param "ActivityName" (optional.String) -  The name of the activity instance.
     * @param "ActivityType" (optional.String) -  The element type of the activity instance.
     * @param "ExecutionId" (optional.String) -  The execution id of the activity instance.
     * @param "Finished" (optional.Bool) -  Indication if the activity instance is finished.
     * @param "TaskAssignee" (optional.String) -  The assignee of the activity instance.
     * @param "ProcessInstanceId" (optional.String) -  The process instance id of the activity instance.
     * @param "ProcessDefinitionId" (optional.String) -  The process definition id of the activity instance.
     * @param "TenantId" (optional.String) -  Only return instances with the given tenantId.
     * @param "TenantIdLike" (optional.String) -  Only return instances with a tenantId like the given value.
     * @param "WithoutTenantId" (optional.Bool) -  If true, only returns instances without a tenantId set. If false, the withoutTenantId parameter is ignored.
@return DataResponseActivityInstanceResponse
*/

type HistoryApiListActivityInstancesOpts struct {
    ActivityId optional.String
    ActivityInstanceId optional.String
    ActivityName optional.String
    ActivityType optional.String
    ExecutionId optional.String
    Finished optional.Bool
    TaskAssignee optional.String
    ProcessInstanceId optional.String
    ProcessDefinitionId optional.String
    TenantId optional.String
    TenantIdLike optional.String
    WithoutTenantId optional.Bool
}

func (a *HistoryApiService) ListActivityInstances(ctx context.Context, localVarOptionals *HistoryApiListActivityInstancesOpts) (DataResponseActivityInstanceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseActivityInstanceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/activity-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ActivityId.IsSet() {
		localVarQueryParams.Add("activityId", parameterToString(localVarOptionals.ActivityId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ActivityInstanceId.IsSet() {
		localVarQueryParams.Add("activityInstanceId", parameterToString(localVarOptionals.ActivityInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ActivityName.IsSet() {
		localVarQueryParams.Add("activityName", parameterToString(localVarOptionals.ActivityName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ActivityType.IsSet() {
		localVarQueryParams.Add("activityType", parameterToString(localVarOptionals.ActivityType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExecutionId.IsSet() {
		localVarQueryParams.Add("executionId", parameterToString(localVarOptionals.ExecutionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Finished.IsSet() {
		localVarQueryParams.Add("finished", parameterToString(localVarOptionals.Finished.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskAssignee.IsSet() {
		localVarQueryParams.Add("taskAssignee", parameterToString(localVarOptionals.TaskAssignee.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessInstanceId.IsSet() {
		localVarQueryParams.Add("processInstanceId", parameterToString(localVarOptionals.ProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionId.IsSet() {
		localVarQueryParams.Add("processDefinitionId", parameterToString(localVarOptionals.ProcessDefinitionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenantId", parameterToString(localVarOptionals.TenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdLike.IsSet() {
		localVarQueryParams.Add("tenantIdLike", parameterToString(localVarOptionals.TenantIdLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutTenantId.IsSet() {
		localVarQueryParams.Add("withoutTenantId", parameterToString(localVarOptionals.WithoutTenantId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseActivityInstanceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryApiService List historic activity instances
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *HistoryApiListHistoricActivityInstancesOpts - Optional Parameters:
     * @param "ActivityId" (optional.String) -  An id of the activity instance.
     * @param "ActivityInstanceId" (optional.String) -  An id of the historic activity instance.
     * @param "ActivityName" (optional.String) -  The name of the historic activity instance.
     * @param "ActivityType" (optional.String) -  The element type of the historic activity instance.
     * @param "ExecutionId" (optional.String) -  The execution id of the historic activity instance.
     * @param "Finished" (optional.Bool) -  Indication if the historic activity instance is finished.
     * @param "TaskAssignee" (optional.String) -  The assignee of the historic activity instance.
     * @param "ProcessInstanceId" (optional.String) -  The process instance id of the historic activity instance.
     * @param "ProcessDefinitionId" (optional.String) -  The process definition id of the historic activity instance.
     * @param "TenantId" (optional.String) -  Only return instances with the given tenantId.
     * @param "TenantIdLike" (optional.String) -  Only return instances with a tenantId like the given value.
     * @param "WithoutTenantId" (optional.Bool) -  If true, only returns instances without a tenantId set. If false, the withoutTenantId parameter is ignored.
@return DataResponseHistoricActivityInstanceResponse
*/

type HistoryApiListHistoricActivityInstancesOpts struct {
    ActivityId optional.String
    ActivityInstanceId optional.String
    ActivityName optional.String
    ActivityType optional.String
    ExecutionId optional.String
    Finished optional.Bool
    TaskAssignee optional.String
    ProcessInstanceId optional.String
    ProcessDefinitionId optional.String
    TenantId optional.String
    TenantIdLike optional.String
    WithoutTenantId optional.Bool
}

func (a *HistoryApiService) ListHistoricActivityInstances(ctx context.Context, localVarOptionals *HistoryApiListHistoricActivityInstancesOpts) (DataResponseHistoricActivityInstanceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseHistoricActivityInstanceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/history/historic-activity-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ActivityId.IsSet() {
		localVarQueryParams.Add("activityId", parameterToString(localVarOptionals.ActivityId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ActivityInstanceId.IsSet() {
		localVarQueryParams.Add("activityInstanceId", parameterToString(localVarOptionals.ActivityInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ActivityName.IsSet() {
		localVarQueryParams.Add("activityName", parameterToString(localVarOptionals.ActivityName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ActivityType.IsSet() {
		localVarQueryParams.Add("activityType", parameterToString(localVarOptionals.ActivityType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExecutionId.IsSet() {
		localVarQueryParams.Add("executionId", parameterToString(localVarOptionals.ExecutionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Finished.IsSet() {
		localVarQueryParams.Add("finished", parameterToString(localVarOptionals.Finished.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskAssignee.IsSet() {
		localVarQueryParams.Add("taskAssignee", parameterToString(localVarOptionals.TaskAssignee.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessInstanceId.IsSet() {
		localVarQueryParams.Add("processInstanceId", parameterToString(localVarOptionals.ProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionId.IsSet() {
		localVarQueryParams.Add("processDefinitionId", parameterToString(localVarOptionals.ProcessDefinitionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenantId", parameterToString(localVarOptionals.TenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdLike.IsSet() {
		localVarQueryParams.Add("tenantIdLike", parameterToString(localVarOptionals.TenantIdLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutTenantId.IsSet() {
		localVarQueryParams.Add("withoutTenantId", parameterToString(localVarOptionals.WithoutTenantId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseHistoricActivityInstanceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryApiService Get historic detail
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *HistoryApiListHistoricDetailsOpts - Optional Parameters:
     * @param "Id" (optional.String) -  The id of the historic detail.
     * @param "ProcessInstanceId" (optional.String) -  The process instance id of the historic detail.
     * @param "ExecutionId" (optional.String) -  The execution id of the historic detail.
     * @param "ActivityInstanceId" (optional.String) -  The activity instance id of the historic detail.
     * @param "TaskId" (optional.String) -  The task id of the historic detail.
     * @param "SelectOnlyFormProperties" (optional.Bool) -  Indication to only return form properties in the result.
     * @param "SelectOnlyVariableUpdates" (optional.Bool) -  Indication to only return variable updates in the result.
@return DataResponseHistoricDetailResponse
*/

type HistoryApiListHistoricDetailsOpts struct {
    Id optional.String
    ProcessInstanceId optional.String
    ExecutionId optional.String
    ActivityInstanceId optional.String
    TaskId optional.String
    SelectOnlyFormProperties optional.Bool
    SelectOnlyVariableUpdates optional.Bool
}

func (a *HistoryApiService) ListHistoricDetails(ctx context.Context, localVarOptionals *HistoryApiListHistoricDetailsOpts) (DataResponseHistoricDetailResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseHistoricDetailResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/history/historic-detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessInstanceId.IsSet() {
		localVarQueryParams.Add("processInstanceId", parameterToString(localVarOptionals.ProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExecutionId.IsSet() {
		localVarQueryParams.Add("executionId", parameterToString(localVarOptionals.ExecutionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ActivityInstanceId.IsSet() {
		localVarQueryParams.Add("activityInstanceId", parameterToString(localVarOptionals.ActivityInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskId.IsSet() {
		localVarQueryParams.Add("taskId", parameterToString(localVarOptionals.TaskId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SelectOnlyFormProperties.IsSet() {
		localVarQueryParams.Add("selectOnlyFormProperties", parameterToString(localVarOptionals.SelectOnlyFormProperties.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SelectOnlyVariableUpdates.IsSet() {
		localVarQueryParams.Add("selectOnlyVariableUpdates", parameterToString(localVarOptionals.SelectOnlyVariableUpdates.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseHistoricDetailResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryApiService List of historic variable instances
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *HistoryApiListHistoricVariableInstancesOpts - Optional Parameters:
     * @param "ProcessInstanceId" (optional.String) -  The process instance id of the historic variable instance.
     * @param "TaskId" (optional.String) -  The task id of the historic variable instance.
     * @param "ExcludeTaskVariables" (optional.Bool) -  Indication to exclude the task variables from the result.
     * @param "ExcludeLocalVariables" (optional.Bool) -  Indication to exclude local variables or not.
     * @param "VariableName" (optional.String) -  The variable name of the historic variable instance.
     * @param "VariableNameLike" (optional.String) -  The variable name using the like operator for the historic variable instance.
@return DataResponseHistoricVariableInstanceResponse
*/

type HistoryApiListHistoricVariableInstancesOpts struct {
    ProcessInstanceId optional.String
    TaskId optional.String
    ExcludeTaskVariables optional.Bool
    ExcludeLocalVariables optional.Bool
    VariableName optional.String
    VariableNameLike optional.String
}

func (a *HistoryApiService) ListHistoricVariableInstances(ctx context.Context, localVarOptionals *HistoryApiListHistoricVariableInstancesOpts) (DataResponseHistoricVariableInstanceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseHistoricVariableInstanceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/history/historic-variable-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ProcessInstanceId.IsSet() {
		localVarQueryParams.Add("processInstanceId", parameterToString(localVarOptionals.ProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskId.IsSet() {
		localVarQueryParams.Add("taskId", parameterToString(localVarOptionals.TaskId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeTaskVariables.IsSet() {
		localVarQueryParams.Add("excludeTaskVariables", parameterToString(localVarOptionals.ExcludeTaskVariables.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeLocalVariables.IsSet() {
		localVarQueryParams.Add("excludeLocalVariables", parameterToString(localVarOptionals.ExcludeLocalVariables.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VariableName.IsSet() {
		localVarQueryParams.Add("variableName", parameterToString(localVarOptionals.VariableName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VariableNameLike.IsSet() {
		localVarQueryParams.Add("variableNameLike", parameterToString(localVarOptionals.VariableNameLike.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseHistoricVariableInstanceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryApiService List of variable instances
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *HistoryApiListVariableInstancesOpts - Optional Parameters:
     * @param "ProcessInstanceId" (optional.String) -  The process instance id of the variable instance.
     * @param "TaskId" (optional.String) -  The task id of the variable instance.
     * @param "ExcludeTaskVariables" (optional.Bool) -  Indication to exclude the task variables from the result.
     * @param "ExcludeLocalVariables" (optional.Bool) -  Indication to exclude local variables or not.
     * @param "VariableName" (optional.String) -  The variable name of the variable instance.
     * @param "VariableNameLike" (optional.String) -  The variable name using the like operator for the variable instance.
@return DataResponseVariableInstanceResponse
*/

type HistoryApiListVariableInstancesOpts struct {
    ProcessInstanceId optional.String
    TaskId optional.String
    ExcludeTaskVariables optional.Bool
    ExcludeLocalVariables optional.Bool
    VariableName optional.String
    VariableNameLike optional.String
}

func (a *HistoryApiService) ListVariableInstances(ctx context.Context, localVarOptionals *HistoryApiListVariableInstancesOpts) (DataResponseVariableInstanceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseVariableInstanceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/variable-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ProcessInstanceId.IsSet() {
		localVarQueryParams.Add("processInstanceId", parameterToString(localVarOptionals.ProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskId.IsSet() {
		localVarQueryParams.Add("taskId", parameterToString(localVarOptionals.TaskId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeTaskVariables.IsSet() {
		localVarQueryParams.Add("excludeTaskVariables", parameterToString(localVarOptionals.ExcludeTaskVariables.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeLocalVariables.IsSet() {
		localVarQueryParams.Add("excludeLocalVariables", parameterToString(localVarOptionals.ExcludeLocalVariables.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VariableName.IsSet() {
		localVarQueryParams.Add("variableName", parameterToString(localVarOptionals.VariableName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.VariableNameLike.IsSet() {
		localVarQueryParams.Add("variableNameLike", parameterToString(localVarOptionals.VariableNameLike.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseVariableInstanceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryApiService Query for historic activity instances
All supported JSON parameter fields allowed are exactly the same as the parameters found for getting a collection of historic task instances, but passed in as JSON-body arguments rather than URL-parameters to allow for more advanced querying and preventing errors with request-uri’s that are too long.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *HistoryApiQueryActivityInstancesOpts - Optional Parameters:
     * @param "Body" (optional.Interface of HistoricActivityInstanceQueryRequest) - 
@return DataResponseHistoricActivityInstanceResponse
*/

type HistoryApiQueryActivityInstancesOpts struct {
    Body optional.Interface
}

func (a *HistoryApiService) QueryActivityInstances(ctx context.Context, localVarOptionals *HistoryApiQueryActivityInstancesOpts) (DataResponseHistoricActivityInstanceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseHistoricActivityInstanceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/query/historic-activity-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseHistoricActivityInstanceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryApiService Query for historic details
All supported JSON parameter fields allowed are exactly the same as the parameters found for getting a collection of historic process instances, but passed in as JSON-body arguments rather than URL-parameters to allow for more advanced querying and preventing errors with request-uri’s that are too long.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *HistoryApiQueryHistoricDetailOpts - Optional Parameters:
     * @param "Body" (optional.Interface of HistoricDetailQueryRequest) - 
@return DataResponseHistoricDetailResponse
*/

type HistoryApiQueryHistoricDetailOpts struct {
    Body optional.Interface
}

func (a *HistoryApiService) QueryHistoricDetail(ctx context.Context, localVarOptionals *HistoryApiQueryHistoricDetailOpts) (DataResponseHistoricDetailResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseHistoricDetailResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/query/historic-detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseHistoricDetailResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryApiService Query for historic variable instances
All supported JSON parameter fields allowed are exactly the same as the parameters found for getting a collection of historic process instances, but passed in as JSON-body arguments rather than URL-parameters to allow for more advanced querying and preventing errors with request-uri’s that are too long. On top of that, the query allows for filtering based on process variables. The variables property is a JSON-array containing objects with the format as described here.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *HistoryApiQueryVariableInstancesOpts - Optional Parameters:
     * @param "Body" (optional.Interface of HistoricVariableInstanceQueryRequest) - 
@return DataResponseHistoricVariableInstanceResponse
*/

type HistoryApiQueryVariableInstancesOpts struct {
    Body optional.Interface
}

func (a *HistoryApiService) QueryVariableInstances(ctx context.Context, localVarOptionals *HistoryApiQueryVariableInstancesOpts) (DataResponseHistoricVariableInstanceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseHistoricVariableInstanceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/query/historic-variable-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseHistoricVariableInstanceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryApiService Query for variable instances
All supported JSON parameter fields allowed are exactly the same as the parameters found for getting a collection of variable instances, but passed in as JSON-body arguments rather than URL-parameters to allow for more advanced querying and preventing errors with request-uri’s that are too long.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *HistoryApiQueryVariableInstances_1Opts - Optional Parameters:
     * @param "Body" (optional.Interface of VariableInstanceQueryRequest) - 
@return DataResponseVariableInstanceResponse
*/

type HistoryApiQueryVariableInstances_1Opts struct {
    Body optional.Interface
}

func (a *HistoryApiService) QueryVariableInstances_1(ctx context.Context, localVarOptionals *HistoryApiQueryVariableInstances_1Opts) (DataResponseVariableInstanceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseVariableInstanceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/query/variable-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseVariableInstanceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
