
/*
 * Flowable REST API
 *
 * # flowable / flowəb(ə)l /    - a compact and highly efficient workflow and Business Process Management (BPM) platform for developers, system admins and business users.  - a lightning fast, tried and tested BPMN 2 process engine written in Java. It is Apache 2.0 licensed open source, with a committed community.  - can run embedded in a Java application, or as a service on a server, a cluster, and in the cloud. It integrates perfectly with Spring. With a rich Java and REST API, it is the ideal engine for orchestrating human or system activities.
 *
 * API version: v1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package bpmn

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type JobsApiService service
/*
JobsApiService Delete a deadletter job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId

*/
func (a *JobsApiService) DeleteDeadLetterJob(ctx context.Context, jobId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/deadletter-jobs/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", fmt.Sprintf("%v", jobId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
JobsApiService Delete a history job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId

*/
func (a *JobsApiService) DeleteHistoryJob(ctx context.Context, jobId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/history-jobs/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", fmt.Sprintf("%v", jobId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
JobsApiService Delete a job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId

*/
func (a *JobsApiService) DeleteJob(ctx context.Context, jobId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/jobs/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", fmt.Sprintf("%v", jobId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
JobsApiService Delete a suspended job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId

*/
func (a *JobsApiService) DeleteSuspendedJob(ctx context.Context, jobId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/suspended-jobs/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", fmt.Sprintf("%v", jobId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
JobsApiService Delete a timer job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId

*/
func (a *JobsApiService) DeleteTimerJob(ctx context.Context, jobId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/timer-jobs/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", fmt.Sprintf("%v", jobId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
JobsApiService Move a bulk of deadletter jobs. Accepts &#x27;move&#x27; and &#x27;moveToHistoryJob&#x27; as action.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *JobsApiExecuteDeadLetterJobActionOpts - Optional Parameters:
     * @param "Body" (optional.Interface of BulkMoveDeadLetterActionRequest) - 

*/

type JobsApiExecuteDeadLetterJobActionOpts struct {
    Body optional.Interface
}

func (a *JobsApiService) ExecuteDeadLetterJobAction(ctx context.Context, localVarOptionals *JobsApiExecuteDeadLetterJobActionOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/deadletter-jobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
JobsApiService Move a single deadletter job. Accepts &#x27;move&#x27; and &#x27;moveToHistoryJob&#x27; as action.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId
 * @param optional nil or *JobsApiExecuteDeadLetterJobAction_1Opts - Optional Parameters:
     * @param "Body" (optional.Interface of RestActionRequest) - 

*/

type JobsApiExecuteDeadLetterJobAction_1Opts struct {
    Body optional.Interface
}

func (a *JobsApiService) ExecuteDeadLetterJobAction_1(ctx context.Context, jobId string, localVarOptionals *JobsApiExecuteDeadLetterJobAction_1Opts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/deadletter-jobs/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", fmt.Sprintf("%v", jobId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
JobsApiService Execute a history job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId
 * @param optional nil or *JobsApiExecuteHistoryJobOpts - Optional Parameters:
     * @param "Body" (optional.Interface of RestActionRequest) - 

*/

type JobsApiExecuteHistoryJobOpts struct {
    Body optional.Interface
}

func (a *JobsApiService) ExecuteHistoryJob(ctx context.Context, jobId string, localVarOptionals *JobsApiExecuteHistoryJobOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/history-jobs/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", fmt.Sprintf("%v", jobId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
JobsApiService Execute a single job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId
 * @param optional nil or *JobsApiExecuteJobActionOpts - Optional Parameters:
     * @param "Body" (optional.Interface of RestActionRequest) - 

*/

type JobsApiExecuteJobActionOpts struct {
    Body optional.Interface
}

func (a *JobsApiService) ExecuteJobAction(ctx context.Context, jobId string, localVarOptionals *JobsApiExecuteJobActionOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/jobs/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", fmt.Sprintf("%v", jobId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
JobsApiService Move a single timer job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId
 * @param optional nil or *JobsApiExecuteTimerJobActionOpts - Optional Parameters:
     * @param "Body" (optional.Interface of RestActionRequest) - 

*/

type JobsApiExecuteTimerJobActionOpts struct {
    Body optional.Interface
}

func (a *JobsApiService) ExecuteTimerJobAction(ctx context.Context, jobId string, localVarOptionals *JobsApiExecuteTimerJobActionOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/timer-jobs/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", fmt.Sprintf("%v", jobId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
JobsApiService Get the exception stacktrace for a deadletter job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId
@return string
*/
func (a *JobsApiService) GetDeadLetterJobStacktrace(ctx context.Context, jobId string) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/deadletter-jobs/{jobId}/exception-stacktrace"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", fmt.Sprintf("%v", jobId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
JobsApiService Get a single deadletter job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId
@return JobResponse
*/
func (a *JobsApiService) GetDeadletterJob(ctx context.Context, jobId string) (JobResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/deadletter-jobs/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", fmt.Sprintf("%v", jobId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v JobResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
JobsApiService Get a single history job job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId
@return HistoryJobResponse
*/
func (a *JobsApiService) GetHistoryJob(ctx context.Context, jobId string) (HistoryJobResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue HistoryJobResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/history-jobs/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", fmt.Sprintf("%v", jobId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v HistoryJobResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
JobsApiService Get a single job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId
@return JobResponse
*/
func (a *JobsApiService) GetJob(ctx context.Context, jobId string) (JobResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/jobs/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", fmt.Sprintf("%v", jobId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v JobResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
JobsApiService Get the exception stacktrace for a job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId
@return string
*/
func (a *JobsApiService) GetJobStacktrace(ctx context.Context, jobId string) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/jobs/{jobId}/exception-stacktrace"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", fmt.Sprintf("%v", jobId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
JobsApiService Get a single suspended job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId
@return JobResponse
*/
func (a *JobsApiService) GetSuspendedJob(ctx context.Context, jobId string) (JobResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/suspended-jobs/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", fmt.Sprintf("%v", jobId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v JobResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
JobsApiService Get the exception stacktrace for a suspended job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId
@return string
*/
func (a *JobsApiService) GetSuspendedJobStacktrace(ctx context.Context, jobId string) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/suspended-jobs/{jobId}/exception-stacktrace"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", fmt.Sprintf("%v", jobId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
JobsApiService Get a single timer job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId
@return JobResponse
*/
func (a *JobsApiService) GetTimerJob(ctx context.Context, jobId string) (JobResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue JobResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/timer-jobs/{jobId}"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", fmt.Sprintf("%v", jobId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v JobResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
JobsApiService Get the exception stacktrace for a timer job
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param jobId
@return string
*/
func (a *JobsApiService) GetTimerJobStacktrace(ctx context.Context, jobId string) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/timer-jobs/{jobId}/exception-stacktrace"
	localVarPath = strings.Replace(localVarPath, "{"+"jobId"+"}", fmt.Sprintf("%v", jobId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
JobsApiService List deadletter jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *JobsApiListDeadLetterJobsOpts - Optional Parameters:
     * @param "Id" (optional.String) -  Only return job with the given id
     * @param "ProcessInstanceId" (optional.String) -  Only return jobs part of a process with the given id
     * @param "WithoutProcessInstanceId" (optional.Bool) -  If true, only returns jobs without a process instance id set. If false, the withoutProcessInstanceId parameter is ignored.
     * @param "ExecutionId" (optional.String) -  Only return jobs part of an execution with the given id
     * @param "ProcessDefinitionId" (optional.String) -  Only return jobs with the given process definition id
     * @param "ElementId" (optional.String) -  Only return jobs with the given element id
     * @param "ElementName" (optional.String) -  Only return jobs with the given element name
     * @param "Executable" (optional.Bool) -  If true, only return jobs which are executable. If false, this parameter is ignored.
     * @param "TimersOnly" (optional.Bool) -  If true, only return jobs which are timers. If false, this parameter is ignored. Cannot be used together with &#x27;messagesOnly&#x27;.
     * @param "MessagesOnly" (optional.Bool) -  If true, only return jobs which are messages. If false, this parameter is ignored. Cannot be used together with &#x27;timersOnly&#x27;
     * @param "WithException" (optional.Bool) -  If true, only return jobs for which an exception occurred while executing it. If false, this parameter is ignored.
     * @param "DueBefore" (optional.Time) -  Only return jobs which are due to be executed before the given date. Jobs without duedate are never returned using this parameter.
     * @param "DueAfter" (optional.Time) -  Only return jobs which are due to be executed after the given date. Jobs without duedate are never returned using this parameter.
     * @param "ExceptionMessage" (optional.String) -  Only return jobs with the given exception message
     * @param "TenantId" (optional.String) -  Only return jobs with the given tenantId.
     * @param "TenantIdLike" (optional.String) -  Only return jobs with a tenantId like the given value.
     * @param "WithoutTenantId" (optional.Bool) -  If true, only returns jobs without a tenantId set. If false, the withoutTenantId parameter is ignored.
     * @param "Locked" (optional.Bool) -  If true, only return jobs which are locked.  If false, this parameter is ignored.
     * @param "Unlocked" (optional.Bool) -  If true, only return jobs which are unlocked. If false, this parameter is ignored.
     * @param "WithoutScopeId" (optional.Bool) -  If true, only returns jobs without a scope id set. If false, the withoutScopeId parameter is ignored.
     * @param "WithoutScopeType" (optional.Bool) -  If true, only returns jobs without a scope type set. If false, the withoutScopeType parameter is ignored.
     * @param "Sort" (optional.String) -  Property to sort on, to be used together with the order.
@return DataResponseJobResponse
*/

type JobsApiListDeadLetterJobsOpts struct {
    Id optional.String
    ProcessInstanceId optional.String
    WithoutProcessInstanceId optional.Bool
    ExecutionId optional.String
    ProcessDefinitionId optional.String
    ElementId optional.String
    ElementName optional.String
    Executable optional.Bool
    TimersOnly optional.Bool
    MessagesOnly optional.Bool
    WithException optional.Bool
    DueBefore optional.Time
    DueAfter optional.Time
    ExceptionMessage optional.String
    TenantId optional.String
    TenantIdLike optional.String
    WithoutTenantId optional.Bool
    Locked optional.Bool
    Unlocked optional.Bool
    WithoutScopeId optional.Bool
    WithoutScopeType optional.Bool
    Sort optional.String
}

func (a *JobsApiService) ListDeadLetterJobs(ctx context.Context, localVarOptionals *JobsApiListDeadLetterJobsOpts) (DataResponseJobResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseJobResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/deadletter-jobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessInstanceId.IsSet() {
		localVarQueryParams.Add("processInstanceId", parameterToString(localVarOptionals.ProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutProcessInstanceId.IsSet() {
		localVarQueryParams.Add("withoutProcessInstanceId", parameterToString(localVarOptionals.WithoutProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExecutionId.IsSet() {
		localVarQueryParams.Add("executionId", parameterToString(localVarOptionals.ExecutionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionId.IsSet() {
		localVarQueryParams.Add("processDefinitionId", parameterToString(localVarOptionals.ProcessDefinitionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ElementId.IsSet() {
		localVarQueryParams.Add("elementId", parameterToString(localVarOptionals.ElementId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ElementName.IsSet() {
		localVarQueryParams.Add("elementName", parameterToString(localVarOptionals.ElementName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Executable.IsSet() {
		localVarQueryParams.Add("executable", parameterToString(localVarOptionals.Executable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TimersOnly.IsSet() {
		localVarQueryParams.Add("timersOnly", parameterToString(localVarOptionals.TimersOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MessagesOnly.IsSet() {
		localVarQueryParams.Add("messagesOnly", parameterToString(localVarOptionals.MessagesOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithException.IsSet() {
		localVarQueryParams.Add("withException", parameterToString(localVarOptionals.WithException.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DueBefore.IsSet() {
		localVarQueryParams.Add("dueBefore", parameterToString(localVarOptionals.DueBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DueAfter.IsSet() {
		localVarQueryParams.Add("dueAfter", parameterToString(localVarOptionals.DueAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExceptionMessage.IsSet() {
		localVarQueryParams.Add("exceptionMessage", parameterToString(localVarOptionals.ExceptionMessage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenantId", parameterToString(localVarOptionals.TenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdLike.IsSet() {
		localVarQueryParams.Add("tenantIdLike", parameterToString(localVarOptionals.TenantIdLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutTenantId.IsSet() {
		localVarQueryParams.Add("withoutTenantId", parameterToString(localVarOptionals.WithoutTenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Locked.IsSet() {
		localVarQueryParams.Add("locked", parameterToString(localVarOptionals.Locked.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Unlocked.IsSet() {
		localVarQueryParams.Add("unlocked", parameterToString(localVarOptionals.Unlocked.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutScopeId.IsSet() {
		localVarQueryParams.Add("withoutScopeId", parameterToString(localVarOptionals.WithoutScopeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutScopeType.IsSet() {
		localVarQueryParams.Add("withoutScopeType", parameterToString(localVarOptionals.WithoutScopeType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseJobResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
JobsApiService List history jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *JobsApiListDeadLetterJobs_2Opts - Optional Parameters:
     * @param "Id" (optional.String) -  Only return the job with the given id
     * @param "WithException" (optional.Bool) -  If true, only return jobs for which an exception occurred while executing it. If false, this parameter is ignored.
     * @param "ExceptionMessage" (optional.String) -  Only return jobs with the given exception message
     * @param "ScopeType" (optional.String) -  Only return jobs with the given scope type
     * @param "TenantId" (optional.String) -  Only return jobs with the given tenantId.
     * @param "TenantIdLike" (optional.String) -  Only return jobs with a tenantId like the given value.
     * @param "WithoutTenantId" (optional.Bool) -  If true, only returns jobs without a tenantId set. If false, the withoutTenantId parameter is ignored.
     * @param "LockOwner" (optional.String) -  If true, only return jobs which are owned by the given lockOwner.
     * @param "Locked" (optional.Bool) -  If true, only return jobs which are locked.  If false, this parameter is ignored.
     * @param "Unlocked" (optional.Bool) -  If true, only return jobs which are unlocked. If false, this parameter is ignored.
     * @param "Sort" (optional.String) -  Property to sort on, to be used together with the order.
@return DataResponseHistoryJobResponse
*/

type JobsApiListDeadLetterJobs_2Opts struct {
    Id optional.String
    WithException optional.Bool
    ExceptionMessage optional.String
    ScopeType optional.String
    TenantId optional.String
    TenantIdLike optional.String
    WithoutTenantId optional.Bool
    LockOwner optional.String
    Locked optional.Bool
    Unlocked optional.Bool
    Sort optional.String
}

func (a *JobsApiService) ListDeadLetterJobs_2(ctx context.Context, localVarOptionals *JobsApiListDeadLetterJobs_2Opts) (DataResponseHistoryJobResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseHistoryJobResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/history-jobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithException.IsSet() {
		localVarQueryParams.Add("withException", parameterToString(localVarOptionals.WithException.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExceptionMessage.IsSet() {
		localVarQueryParams.Add("exceptionMessage", parameterToString(localVarOptionals.ExceptionMessage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeType.IsSet() {
		localVarQueryParams.Add("scopeType", parameterToString(localVarOptionals.ScopeType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenantId", parameterToString(localVarOptionals.TenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdLike.IsSet() {
		localVarQueryParams.Add("tenantIdLike", parameterToString(localVarOptionals.TenantIdLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutTenantId.IsSet() {
		localVarQueryParams.Add("withoutTenantId", parameterToString(localVarOptionals.WithoutTenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.LockOwner.IsSet() {
		localVarQueryParams.Add("lockOwner", parameterToString(localVarOptionals.LockOwner.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Locked.IsSet() {
		localVarQueryParams.Add("locked", parameterToString(localVarOptionals.Locked.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Unlocked.IsSet() {
		localVarQueryParams.Add("unlocked", parameterToString(localVarOptionals.Unlocked.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseHistoryJobResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
JobsApiService List jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *JobsApiListJobsOpts - Optional Parameters:
     * @param "Id" (optional.String) -  Only return job with the given id
     * @param "ProcessInstanceId" (optional.String) -  Only return jobs part of a process with the given id
     * @param "WithoutProcessInstanceId" (optional.Bool) -  If true, only returns jobs without a process instance id set. If false, the withoutProcessInstanceId parameter is ignored.
     * @param "ExecutionId" (optional.String) -  Only return jobs part of an execution with the given id
     * @param "ProcessDefinitionId" (optional.String) -  Only return jobs with the given process definition id
     * @param "ElementId" (optional.String) -  Only return jobs with the given element id
     * @param "ElementName" (optional.String) -  Only return jobs with the given element name
     * @param "TimersOnly" (optional.Bool) -  If true, only return jobs which are timers. If false, this parameter is ignored. Cannot be used together with &#x27;messagesOnly&#x27;.
     * @param "MessagesOnly" (optional.Bool) -  If true, only return jobs which are messages. If false, this parameter is ignored. Cannot be used together with &#x27;timersOnly&#x27;
     * @param "WithException" (optional.Bool) -  If true, only return jobs for which an exception occurred while executing it. If false, this parameter is ignored.
     * @param "DueBefore" (optional.Time) -  Only return jobs which are due to be executed before the given date. Jobs without duedate are never returned using this parameter.
     * @param "DueAfter" (optional.Time) -  Only return jobs which are due to be executed after the given date. Jobs without duedate are never returned using this parameter.
     * @param "ExceptionMessage" (optional.String) -  Only return jobs with the given exception message
     * @param "TenantId" (optional.String) -  Only return jobs with the given tenantId.
     * @param "TenantIdLike" (optional.String) -  Only return jobs with a tenantId like the given value.
     * @param "WithoutTenantId" (optional.Bool) -  If true, only returns jobs without a tenantId set. If false, the withoutTenantId parameter is ignored.
     * @param "Locked" (optional.Bool) -  If true, only return jobs which are locked.  If false, this parameter is ignored.
     * @param "Unlocked" (optional.Bool) -  If true, only return jobs which are unlocked. If false, this parameter is ignored.
     * @param "WithoutScopeId" (optional.Bool) -  If true, only returns jobs without a scope id set. If false, the withoutScopeId parameter is ignored.
     * @param "WithoutScopeType" (optional.Bool) -  If true, only returns jobs without a scope type set. If false, the withoutScopeType parameter is ignored.
     * @param "Sort" (optional.String) -  Property to sort on, to be used together with the order.
@return DataResponseJobResponse
*/

type JobsApiListJobsOpts struct {
    Id optional.String
    ProcessInstanceId optional.String
    WithoutProcessInstanceId optional.Bool
    ExecutionId optional.String
    ProcessDefinitionId optional.String
    ElementId optional.String
    ElementName optional.String
    TimersOnly optional.Bool
    MessagesOnly optional.Bool
    WithException optional.Bool
    DueBefore optional.Time
    DueAfter optional.Time
    ExceptionMessage optional.String
    TenantId optional.String
    TenantIdLike optional.String
    WithoutTenantId optional.Bool
    Locked optional.Bool
    Unlocked optional.Bool
    WithoutScopeId optional.Bool
    WithoutScopeType optional.Bool
    Sort optional.String
}

func (a *JobsApiService) ListJobs(ctx context.Context, localVarOptionals *JobsApiListJobsOpts) (DataResponseJobResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseJobResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/jobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessInstanceId.IsSet() {
		localVarQueryParams.Add("processInstanceId", parameterToString(localVarOptionals.ProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutProcessInstanceId.IsSet() {
		localVarQueryParams.Add("withoutProcessInstanceId", parameterToString(localVarOptionals.WithoutProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExecutionId.IsSet() {
		localVarQueryParams.Add("executionId", parameterToString(localVarOptionals.ExecutionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionId.IsSet() {
		localVarQueryParams.Add("processDefinitionId", parameterToString(localVarOptionals.ProcessDefinitionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ElementId.IsSet() {
		localVarQueryParams.Add("elementId", parameterToString(localVarOptionals.ElementId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ElementName.IsSet() {
		localVarQueryParams.Add("elementName", parameterToString(localVarOptionals.ElementName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TimersOnly.IsSet() {
		localVarQueryParams.Add("timersOnly", parameterToString(localVarOptionals.TimersOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MessagesOnly.IsSet() {
		localVarQueryParams.Add("messagesOnly", parameterToString(localVarOptionals.MessagesOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithException.IsSet() {
		localVarQueryParams.Add("withException", parameterToString(localVarOptionals.WithException.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DueBefore.IsSet() {
		localVarQueryParams.Add("dueBefore", parameterToString(localVarOptionals.DueBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DueAfter.IsSet() {
		localVarQueryParams.Add("dueAfter", parameterToString(localVarOptionals.DueAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExceptionMessage.IsSet() {
		localVarQueryParams.Add("exceptionMessage", parameterToString(localVarOptionals.ExceptionMessage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenantId", parameterToString(localVarOptionals.TenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdLike.IsSet() {
		localVarQueryParams.Add("tenantIdLike", parameterToString(localVarOptionals.TenantIdLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutTenantId.IsSet() {
		localVarQueryParams.Add("withoutTenantId", parameterToString(localVarOptionals.WithoutTenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Locked.IsSet() {
		localVarQueryParams.Add("locked", parameterToString(localVarOptionals.Locked.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Unlocked.IsSet() {
		localVarQueryParams.Add("unlocked", parameterToString(localVarOptionals.Unlocked.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutScopeId.IsSet() {
		localVarQueryParams.Add("withoutScopeId", parameterToString(localVarOptionals.WithoutScopeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutScopeType.IsSet() {
		localVarQueryParams.Add("withoutScopeType", parameterToString(localVarOptionals.WithoutScopeType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseJobResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
JobsApiService List suspended jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *JobsApiListSuspendedJobsOpts - Optional Parameters:
     * @param "Id" (optional.String) -  Only return job with the given id
     * @param "ProcessInstanceId" (optional.String) -  Only return jobs part of a process with the given id
     * @param "WithoutProcessInstanceId" (optional.Bool) -  If true, only returns jobs without a process instance id set. If false, the withoutProcessInstanceId parameter is ignored.
     * @param "ExecutionId" (optional.String) -  Only return jobs part of an execution with the given id
     * @param "ProcessDefinitionId" (optional.String) -  Only return jobs with the given process definition id
     * @param "ElementId" (optional.String) -  Only return jobs with the given element id
     * @param "ElementName" (optional.String) -  Only return jobs with the given element name
     * @param "Executable" (optional.Bool) -  If true, only return jobs which are executable. If false, this parameter is ignored.
     * @param "TimersOnly" (optional.Bool) -  If true, only return jobs which are timers. If false, this parameter is ignored. Cannot be used together with &#x27;messagesOnly&#x27;.
     * @param "MessagesOnly" (optional.Bool) -  If true, only return jobs which are messages. If false, this parameter is ignored. Cannot be used together with &#x27;timersOnly&#x27;
     * @param "WithException" (optional.Bool) -  If true, only return jobs for which an exception occurred while executing it. If false, this parameter is ignored.
     * @param "DueBefore" (optional.Time) -  Only return jobs which are due to be executed before the given date. Jobs without duedate are never returned using this parameter.
     * @param "DueAfter" (optional.Time) -  Only return jobs which are due to be executed after the given date. Jobs without duedate are never returned using this parameter.
     * @param "ExceptionMessage" (optional.String) -  Only return jobs with the given exception message
     * @param "TenantId" (optional.String) -  Only return jobs with the given tenantId.
     * @param "TenantIdLike" (optional.String) -  Only return jobs with a tenantId like the given value.
     * @param "WithoutTenantId" (optional.Bool) -  If true, only returns jobs without a tenantId set. If false, the withoutTenantId parameter is ignored.
     * @param "Locked" (optional.Bool) -  If true, only return jobs which are locked.  If false, this parameter is ignored.
     * @param "Unlocked" (optional.Bool) -  If true, only return jobs which are unlocked. If false, this parameter is ignored.
     * @param "WithoutScopeId" (optional.Bool) -  If true, only returns jobs without a scope id set. If false, the withoutScopeId parameter is ignored.
     * @param "WithoutScopeType" (optional.Bool) -  If true, only returns jobs without a scope type set. If false, the withoutScopeType parameter is ignored.
     * @param "Sort" (optional.String) -  Property to sort on, to be used together with the order.
@return DataResponseJobResponse
*/

type JobsApiListSuspendedJobsOpts struct {
    Id optional.String
    ProcessInstanceId optional.String
    WithoutProcessInstanceId optional.Bool
    ExecutionId optional.String
    ProcessDefinitionId optional.String
    ElementId optional.String
    ElementName optional.String
    Executable optional.Bool
    TimersOnly optional.Bool
    MessagesOnly optional.Bool
    WithException optional.Bool
    DueBefore optional.Time
    DueAfter optional.Time
    ExceptionMessage optional.String
    TenantId optional.String
    TenantIdLike optional.String
    WithoutTenantId optional.Bool
    Locked optional.Bool
    Unlocked optional.Bool
    WithoutScopeId optional.Bool
    WithoutScopeType optional.Bool
    Sort optional.String
}

func (a *JobsApiService) ListSuspendedJobs(ctx context.Context, localVarOptionals *JobsApiListSuspendedJobsOpts) (DataResponseJobResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseJobResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/suspended-jobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessInstanceId.IsSet() {
		localVarQueryParams.Add("processInstanceId", parameterToString(localVarOptionals.ProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutProcessInstanceId.IsSet() {
		localVarQueryParams.Add("withoutProcessInstanceId", parameterToString(localVarOptionals.WithoutProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExecutionId.IsSet() {
		localVarQueryParams.Add("executionId", parameterToString(localVarOptionals.ExecutionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionId.IsSet() {
		localVarQueryParams.Add("processDefinitionId", parameterToString(localVarOptionals.ProcessDefinitionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ElementId.IsSet() {
		localVarQueryParams.Add("elementId", parameterToString(localVarOptionals.ElementId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ElementName.IsSet() {
		localVarQueryParams.Add("elementName", parameterToString(localVarOptionals.ElementName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Executable.IsSet() {
		localVarQueryParams.Add("executable", parameterToString(localVarOptionals.Executable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TimersOnly.IsSet() {
		localVarQueryParams.Add("timersOnly", parameterToString(localVarOptionals.TimersOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MessagesOnly.IsSet() {
		localVarQueryParams.Add("messagesOnly", parameterToString(localVarOptionals.MessagesOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithException.IsSet() {
		localVarQueryParams.Add("withException", parameterToString(localVarOptionals.WithException.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DueBefore.IsSet() {
		localVarQueryParams.Add("dueBefore", parameterToString(localVarOptionals.DueBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DueAfter.IsSet() {
		localVarQueryParams.Add("dueAfter", parameterToString(localVarOptionals.DueAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExceptionMessage.IsSet() {
		localVarQueryParams.Add("exceptionMessage", parameterToString(localVarOptionals.ExceptionMessage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenantId", parameterToString(localVarOptionals.TenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdLike.IsSet() {
		localVarQueryParams.Add("tenantIdLike", parameterToString(localVarOptionals.TenantIdLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutTenantId.IsSet() {
		localVarQueryParams.Add("withoutTenantId", parameterToString(localVarOptionals.WithoutTenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Locked.IsSet() {
		localVarQueryParams.Add("locked", parameterToString(localVarOptionals.Locked.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Unlocked.IsSet() {
		localVarQueryParams.Add("unlocked", parameterToString(localVarOptionals.Unlocked.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutScopeId.IsSet() {
		localVarQueryParams.Add("withoutScopeId", parameterToString(localVarOptionals.WithoutScopeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutScopeType.IsSet() {
		localVarQueryParams.Add("withoutScopeType", parameterToString(localVarOptionals.WithoutScopeType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseJobResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
JobsApiService List timer jobs
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *JobsApiListTimerJobsOpts - Optional Parameters:
     * @param "Id" (optional.String) -  Only return job with the given id
     * @param "ProcessInstanceId" (optional.String) -  Only return jobs part of a process with the given id
     * @param "WithoutProcessInstanceId" (optional.Bool) -  If true, only returns jobs without a process instance id set. If false, the withoutProcessInstanceId parameter is ignored.
     * @param "ExecutionId" (optional.String) -  Only return jobs part of an execution with the given id
     * @param "ProcessDefinitionId" (optional.String) -  Only return jobs with the given process definition id
     * @param "ElementId" (optional.String) -  Only return jobs with the given element id
     * @param "ElementName" (optional.String) -  Only return jobs with the given element name
     * @param "Executable" (optional.Bool) -  If true, only return jobs which are executable. If false, this parameter is ignored.
     * @param "TimersOnly" (optional.Bool) -  If true, only return jobs which are timers. If false, this parameter is ignored. Cannot be used together with &#x27;messagesOnly&#x27;.
     * @param "MessagesOnly" (optional.Bool) -  If true, only return jobs which are messages. If false, this parameter is ignored. Cannot be used together with &#x27;timersOnly&#x27;
     * @param "WithException" (optional.Bool) -  If true, only return jobs for which an exception occurred while executing it. If false, this parameter is ignored.
     * @param "DueBefore" (optional.Time) -  Only return jobs which are due to be executed before the given date. Jobs without duedate are never returned using this parameter.
     * @param "DueAfter" (optional.Time) -  Only return jobs which are due to be executed after the given date. Jobs without duedate are never returned using this parameter.
     * @param "ExceptionMessage" (optional.String) -  Only return jobs with the given exception message
     * @param "TenantId" (optional.String) -  Only return jobs with the given tenantId.
     * @param "TenantIdLike" (optional.String) -  Only return jobs with a tenantId like the given value.
     * @param "WithoutTenantId" (optional.Bool) -  If true, only returns jobs without a tenantId set. If false, the withoutTenantId parameter is ignored.
     * @param "Locked" (optional.Bool) -  If true, only return jobs which are locked.  If false, this parameter is ignored.
     * @param "Unlocked" (optional.Bool) -  If true, only return jobs which are unlocked. If false, this parameter is ignored.
     * @param "WithoutScopeId" (optional.Bool) -  If true, only returns jobs without a scope id set. If false, the withoutScopeId parameter is ignored.
     * @param "WithoutScopeType" (optional.Bool) -  If true, only returns jobs without a scope type set. If false, the withoutScopeType parameter is ignored.
     * @param "Sort" (optional.String) -  Property to sort on, to be used together with the order.
@return DataResponseJobResponse
*/

type JobsApiListTimerJobsOpts struct {
    Id optional.String
    ProcessInstanceId optional.String
    WithoutProcessInstanceId optional.Bool
    ExecutionId optional.String
    ProcessDefinitionId optional.String
    ElementId optional.String
    ElementName optional.String
    Executable optional.Bool
    TimersOnly optional.Bool
    MessagesOnly optional.Bool
    WithException optional.Bool
    DueBefore optional.Time
    DueAfter optional.Time
    ExceptionMessage optional.String
    TenantId optional.String
    TenantIdLike optional.String
    WithoutTenantId optional.Bool
    Locked optional.Bool
    Unlocked optional.Bool
    WithoutScopeId optional.Bool
    WithoutScopeType optional.Bool
    Sort optional.String
}

func (a *JobsApiService) ListTimerJobs(ctx context.Context, localVarOptionals *JobsApiListTimerJobsOpts) (DataResponseJobResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseJobResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/management/timer-jobs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessInstanceId.IsSet() {
		localVarQueryParams.Add("processInstanceId", parameterToString(localVarOptionals.ProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutProcessInstanceId.IsSet() {
		localVarQueryParams.Add("withoutProcessInstanceId", parameterToString(localVarOptionals.WithoutProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExecutionId.IsSet() {
		localVarQueryParams.Add("executionId", parameterToString(localVarOptionals.ExecutionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionId.IsSet() {
		localVarQueryParams.Add("processDefinitionId", parameterToString(localVarOptionals.ProcessDefinitionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ElementId.IsSet() {
		localVarQueryParams.Add("elementId", parameterToString(localVarOptionals.ElementId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ElementName.IsSet() {
		localVarQueryParams.Add("elementName", parameterToString(localVarOptionals.ElementName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Executable.IsSet() {
		localVarQueryParams.Add("executable", parameterToString(localVarOptionals.Executable.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TimersOnly.IsSet() {
		localVarQueryParams.Add("timersOnly", parameterToString(localVarOptionals.TimersOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MessagesOnly.IsSet() {
		localVarQueryParams.Add("messagesOnly", parameterToString(localVarOptionals.MessagesOnly.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithException.IsSet() {
		localVarQueryParams.Add("withException", parameterToString(localVarOptionals.WithException.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DueBefore.IsSet() {
		localVarQueryParams.Add("dueBefore", parameterToString(localVarOptionals.DueBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DueAfter.IsSet() {
		localVarQueryParams.Add("dueAfter", parameterToString(localVarOptionals.DueAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExceptionMessage.IsSet() {
		localVarQueryParams.Add("exceptionMessage", parameterToString(localVarOptionals.ExceptionMessage.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenantId", parameterToString(localVarOptionals.TenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdLike.IsSet() {
		localVarQueryParams.Add("tenantIdLike", parameterToString(localVarOptionals.TenantIdLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutTenantId.IsSet() {
		localVarQueryParams.Add("withoutTenantId", parameterToString(localVarOptionals.WithoutTenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Locked.IsSet() {
		localVarQueryParams.Add("locked", parameterToString(localVarOptionals.Locked.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Unlocked.IsSet() {
		localVarQueryParams.Add("unlocked", parameterToString(localVarOptionals.Unlocked.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutScopeId.IsSet() {
		localVarQueryParams.Add("withoutScopeId", parameterToString(localVarOptionals.WithoutScopeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutScopeType.IsSet() {
		localVarQueryParams.Add("withoutScopeType", parameterToString(localVarOptionals.WithoutScopeType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseJobResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
