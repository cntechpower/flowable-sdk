
/*
 * Flowable REST API
 *
 * # flowable / flowəb(ə)l /    - a compact and highly efficient workflow and Business Process Management (BPM) platform for developers, system admins and business users.  - a lightning fast, tried and tested BPMN 2 process engine written in Java. It is Apache 2.0 licensed open source, with a committed community.  - can run embedded in a Java application, or as a service on a server, a cluster, and in the cloud. It integrates perfectly with Spring. With a rich Java and REST API, it is the ideal engine for orchestrating human or system activities.
 *
 * API version: v1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package bpmn

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type ProcessInstancesApiService service
/*
ProcessInstancesApiService Change the state a process instance
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param processInstanceId
 * @param optional nil or *ProcessInstancesApiChangeActivityStateOpts - Optional Parameters:
     * @param "Body" (optional.Interface of ExecutionChangeActivityStateRequest) - 

*/

type ProcessInstancesApiChangeActivityStateOpts struct {
    Body optional.Interface
}

func (a *ProcessInstancesApiService) ChangeActivityState(ctx context.Context, processInstanceId string, localVarOptionals *ProcessInstancesApiChangeActivityStateOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/process-instances/{processInstanceId}/change-state"
	localVarPath = strings.Replace(localVarPath, "{"+"processInstanceId"+"}", fmt.Sprintf("%v", processInstanceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ProcessInstancesApiService Start a process instance
Note that also a *transientVariables* property is accepted as part of this json, that follows the same structure as the *variables* property.  Only one of *processDefinitionId*, *processDefinitionKey* or *message* can be used in the request body.   Parameters *businessKey*, *variables* and *tenantId* are optional.   If tenantId is omitted, the default tenant will be used. More information about the variable format can be found in the REST variables section.   Note that the variable-scope that is supplied is ignored, process-variables are always local.  
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ProcessInstancesApiCreateProcessInstanceOpts - Optional Parameters:
     * @param "Body" (optional.Interface of ProcessInstanceCreateRequest) - 
@return ProcessInstanceResponse
*/

type ProcessInstancesApiCreateProcessInstanceOpts struct {
    Body optional.Interface
}

func (a *ProcessInstancesApiService) CreateProcessInstance(ctx context.Context, localVarOptionals *ProcessInstancesApiCreateProcessInstanceOpts) (ProcessInstanceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ProcessInstanceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/process-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ProcessInstanceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ProcessInstancesApiService Delete a process instance
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param processInstanceId
 * @param optional nil or *ProcessInstancesApiDeleteProcessInstanceOpts - Optional Parameters:
     * @param "DeleteReason" (optional.String) - 

*/

type ProcessInstancesApiDeleteProcessInstanceOpts struct {
    DeleteReason optional.String
}

func (a *ProcessInstancesApiService) DeleteProcessInstance(ctx context.Context, processInstanceId string, localVarOptionals *ProcessInstancesApiDeleteProcessInstanceOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/process-instances/{processInstanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"processInstanceId"+"}", fmt.Sprintf("%v", processInstanceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.DeleteReason.IsSet() {
		localVarQueryParams.Add("deleteReason", parameterToString(localVarOptionals.DeleteReason.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ProcessInstancesApiService Bulk delete process instances
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ProcessInstancesApiDeleteProcessInstancesOpts - Optional Parameters:
     * @param "Body" (optional.Interface of BulkDeleteInstancesRestActionRequest) - 

*/

type ProcessInstancesApiDeleteProcessInstancesOpts struct {
    Body optional.Interface
}

func (a *ProcessInstancesApiService) DeleteProcessInstances(ctx context.Context, localVarOptionals *ProcessInstancesApiDeleteProcessInstancesOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/process-instances/delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ProcessInstancesApiService Evaluate the conditions of a process instance
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param processInstanceId

*/
func (a *ProcessInstancesApiService) EvaluateConditions(ctx context.Context, processInstanceId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/process-instances/{processInstanceId}/evaluate-conditions"
	localVarPath = strings.Replace(localVarPath, "{"+"processInstanceId"+"}", fmt.Sprintf("%v", processInstanceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ProcessInstancesApiService Get a process instance
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param processInstanceId
@return ProcessInstanceResponse
*/
func (a *ProcessInstancesApiService) GetProcessInstance(ctx context.Context, processInstanceId string) (ProcessInstanceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ProcessInstanceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/process-instances/{processInstanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"processInstanceId"+"}", fmt.Sprintf("%v", processInstanceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ProcessInstanceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ProcessInstancesApiService Get diagram for a process instance
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param processInstanceId
@return []string
*/
func (a *ProcessInstancesApiService) GetProcessInstanceDiagram(ctx context.Context, processInstanceId string) ([]string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/process-instances/{processInstanceId}/diagram"
	localVarPath = strings.Replace(localVarPath, "{"+"processInstanceId"+"}", fmt.Sprintf("%v", processInstanceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ProcessInstancesApiService Inject activity in a process instance
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param processInstanceId
 * @param optional nil or *ProcessInstancesApiInjectActivityInProcessInstanceOpts - Optional Parameters:
     * @param "Body" (optional.Interface of InjectActivityRequest) - 

*/

type ProcessInstancesApiInjectActivityInProcessInstanceOpts struct {
    Body optional.Interface
}

func (a *ProcessInstancesApiService) InjectActivityInProcessInstance(ctx context.Context, processInstanceId string, localVarOptionals *ProcessInstancesApiInjectActivityInProcessInstanceOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/process-instances/{processInstanceId}/inject"
	localVarPath = strings.Replace(localVarPath, "{"+"processInstanceId"+"}", fmt.Sprintf("%v", processInstanceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ProcessInstancesApiService List process instances
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ProcessInstancesApiListProcessInstancesOpts - Optional Parameters:
     * @param "Id" (optional.String) -  Only return models with the given version.
     * @param "Name" (optional.String) -  Only return models with the given name.
     * @param "NameLike" (optional.String) -  Only return models like the given name.
     * @param "NameLikeIgnoreCase" (optional.String) -  Only return models like the given name ignoring case.
     * @param "ProcessDefinitionKey" (optional.String) -  Only return process instances with the given process definition key.
     * @param "ProcessDefinitionId" (optional.String) -  Only return process instances with the given process definition id.
     * @param "ProcessDefinitionCategory" (optional.String) -  Only return process instances with the given process definition category.
     * @param "ProcessDefinitionVersion" (optional.Int32) -  Only return process instances with the given process definition version.
     * @param "ProcessDefinitionEngineVersion" (optional.String) -  Only return process instances with the given process definition engine version.
     * @param "BusinessKey" (optional.String) -  Only return process instances with the given businessKey.
     * @param "BusinessKeyLike" (optional.String) -  Only return process instances with the businessKey like the given key.
     * @param "StartedBy" (optional.String) -  Only return process instances started by the given user.
     * @param "StartedBefore" (optional.Time) -  Only return process instances started before the given date.
     * @param "StartedAfter" (optional.Time) -  Only return process instances started after the given date.
     * @param "ActiveActivityId" (optional.String) -  Only return process instances which have an active activity instance with the provided activity id.
     * @param "InvolvedUser" (optional.String) -  Only return process instances in which the given user is involved.
     * @param "Suspended" (optional.Bool) -  If true, only return process instance which are suspended. If false, only return process instances which are not suspended (active).
     * @param "SuperProcessInstanceId" (optional.String) -  Only return process instances which have the given super process-instance id (for processes that have a call-activities).
     * @param "SubProcessInstanceId" (optional.String) -  Only return process instances which have the given sub process-instance id (for processes started as a call-activity).
     * @param "ExcludeSubprocesses" (optional.Bool) -  Return only process instances which are not sub processes.
     * @param "IncludeProcessVariables" (optional.Bool) -  Indication to include process variables in the result.
     * @param "CallbackId" (optional.String) -  Only return process instances with the given callbackId.
     * @param "CallbackType" (optional.String) -  Only return process instances with the given callbackType.
     * @param "TenantId" (optional.String) -  Only return process instances with the given tenantId.
     * @param "TenantIdLike" (optional.String) -  Only return process instances with a tenantId like the given value.
     * @param "WithoutTenantId" (optional.Bool) -  If true, only returns process instances without a tenantId set. If false, the withoutTenantId parameter is ignored.
     * @param "Sort" (optional.String) -  Property to sort on, to be used together with the order.
@return DataResponseProcessInstanceResponse
*/

type ProcessInstancesApiListProcessInstancesOpts struct {
    Id optional.String
    Name optional.String
    NameLike optional.String
    NameLikeIgnoreCase optional.String
    ProcessDefinitionKey optional.String
    ProcessDefinitionId optional.String
    ProcessDefinitionCategory optional.String
    ProcessDefinitionVersion optional.Int32
    ProcessDefinitionEngineVersion optional.String
    BusinessKey optional.String
    BusinessKeyLike optional.String
    StartedBy optional.String
    StartedBefore optional.Time
    StartedAfter optional.Time
    ActiveActivityId optional.String
    InvolvedUser optional.String
    Suspended optional.Bool
    SuperProcessInstanceId optional.String
    SubProcessInstanceId optional.String
    ExcludeSubprocesses optional.Bool
    IncludeProcessVariables optional.Bool
    CallbackId optional.String
    CallbackType optional.String
    TenantId optional.String
    TenantIdLike optional.String
    WithoutTenantId optional.Bool
    Sort optional.String
}

func (a *ProcessInstancesApiService) ListProcessInstances(ctx context.Context, localVarOptionals *ProcessInstancesApiListProcessInstancesOpts) (DataResponseProcessInstanceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseProcessInstanceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/process-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameLike.IsSet() {
		localVarQueryParams.Add("nameLike", parameterToString(localVarOptionals.NameLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameLikeIgnoreCase.IsSet() {
		localVarQueryParams.Add("nameLikeIgnoreCase", parameterToString(localVarOptionals.NameLikeIgnoreCase.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionKey.IsSet() {
		localVarQueryParams.Add("processDefinitionKey", parameterToString(localVarOptionals.ProcessDefinitionKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionId.IsSet() {
		localVarQueryParams.Add("processDefinitionId", parameterToString(localVarOptionals.ProcessDefinitionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionCategory.IsSet() {
		localVarQueryParams.Add("processDefinitionCategory", parameterToString(localVarOptionals.ProcessDefinitionCategory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionVersion.IsSet() {
		localVarQueryParams.Add("processDefinitionVersion", parameterToString(localVarOptionals.ProcessDefinitionVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionEngineVersion.IsSet() {
		localVarQueryParams.Add("processDefinitionEngineVersion", parameterToString(localVarOptionals.ProcessDefinitionEngineVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BusinessKey.IsSet() {
		localVarQueryParams.Add("businessKey", parameterToString(localVarOptionals.BusinessKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BusinessKeyLike.IsSet() {
		localVarQueryParams.Add("businessKeyLike", parameterToString(localVarOptionals.BusinessKeyLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartedBy.IsSet() {
		localVarQueryParams.Add("startedBy", parameterToString(localVarOptionals.StartedBy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartedBefore.IsSet() {
		localVarQueryParams.Add("startedBefore", parameterToString(localVarOptionals.StartedBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartedAfter.IsSet() {
		localVarQueryParams.Add("startedAfter", parameterToString(localVarOptionals.StartedAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ActiveActivityId.IsSet() {
		localVarQueryParams.Add("activeActivityId", parameterToString(localVarOptionals.ActiveActivityId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InvolvedUser.IsSet() {
		localVarQueryParams.Add("involvedUser", parameterToString(localVarOptionals.InvolvedUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Suspended.IsSet() {
		localVarQueryParams.Add("suspended", parameterToString(localVarOptionals.Suspended.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SuperProcessInstanceId.IsSet() {
		localVarQueryParams.Add("superProcessInstanceId", parameterToString(localVarOptionals.SuperProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubProcessInstanceId.IsSet() {
		localVarQueryParams.Add("subProcessInstanceId", parameterToString(localVarOptionals.SubProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeSubprocesses.IsSet() {
		localVarQueryParams.Add("excludeSubprocesses", parameterToString(localVarOptionals.ExcludeSubprocesses.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeProcessVariables.IsSet() {
		localVarQueryParams.Add("includeProcessVariables", parameterToString(localVarOptionals.IncludeProcessVariables.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CallbackId.IsSet() {
		localVarQueryParams.Add("callbackId", parameterToString(localVarOptionals.CallbackId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CallbackType.IsSet() {
		localVarQueryParams.Add("callbackType", parameterToString(localVarOptionals.CallbackType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenantId", parameterToString(localVarOptionals.TenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdLike.IsSet() {
		localVarQueryParams.Add("tenantIdLike", parameterToString(localVarOptionals.TenantIdLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutTenantId.IsSet() {
		localVarQueryParams.Add("withoutTenantId", parameterToString(localVarOptionals.WithoutTenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseProcessInstanceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ProcessInstancesApiService Migrate process instance
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param processInstanceId
 * @param optional nil or *ProcessInstancesApiMigrateProcessInstanceOpts - Optional Parameters:
     * @param "Body" (optional.Interface of string) - 

*/

type ProcessInstancesApiMigrateProcessInstanceOpts struct {
    Body optional.Interface
}

func (a *ProcessInstancesApiService) MigrateProcessInstance(ctx context.Context, processInstanceId string, localVarOptionals *ProcessInstancesApiMigrateProcessInstanceOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/process-instances/{processInstanceId}/migrate"
	localVarPath = strings.Replace(localVarPath, "{"+"processInstanceId"+"}", fmt.Sprintf("%v", processInstanceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
ProcessInstancesApiService Query process instances
The request body can contain all possible filters that can be used in the List process instances URL query. On top of these, it’s possible to provide an array of variables to include in the query, with their format described here.  The general paging and sorting query-parameters can be used for this URL.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ProcessInstancesApiQueryProcessInstancesOpts - Optional Parameters:
     * @param "Body" (optional.Interface of ProcessInstanceQueryRequest) - 
@return DataResponseProcessInstanceResponse
*/

type ProcessInstancesApiQueryProcessInstancesOpts struct {
    Body optional.Interface
}

func (a *ProcessInstancesApiService) QueryProcessInstances(ctx context.Context, localVarOptionals *ProcessInstancesApiQueryProcessInstancesOpts) (DataResponseProcessInstanceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseProcessInstanceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/query/process-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseProcessInstanceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
ProcessInstancesApiService Update process instance properties or execute an action on a process instance (body needs to contain an &#x27;action&#x27; property for the latter).
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param processInstanceId
 * @param optional nil or *ProcessInstancesApiUpdateProcessInstanceOpts - Optional Parameters:
     * @param "Body" (optional.Interface of ProcessInstanceUpdateRequest) - 
@return ProcessInstanceResponse
*/

type ProcessInstancesApiUpdateProcessInstanceOpts struct {
    Body optional.Interface
}

func (a *ProcessInstancesApiService) UpdateProcessInstance(ctx context.Context, processInstanceId string, localVarOptionals *ProcessInstancesApiUpdateProcessInstanceOpts) (ProcessInstanceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ProcessInstanceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/process-instances/{processInstanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"processInstanceId"+"}", fmt.Sprintf("%v", processInstanceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v ProcessInstanceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
