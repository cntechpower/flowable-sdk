
/*
 * Flowable REST API
 *
 * # flowable / flowəb(ə)l /    - a compact and highly efficient workflow and Business Process Management (BPM) platform for developers, system admins and business users.  - a lightning fast, tried and tested BPMN 2 process engine written in Java. It is Apache 2.0 licensed open source, with a committed community.  - can run embedded in a Java application, or as a service on a server, a cluster, and in the cloud. It integrates perfectly with Spring. With a rich Java and REST API, it is the ideal engine for orchestrating human or system activities.
 *
 * API version: v1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package bpmn

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type HistoryProcessApiService service
/*
HistoryProcessApiService Create a new comment on a historic process instance
Parameter saveProcessInstanceId is optional, if true save process instance id of task with comment.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param processInstanceId
 * @param optional nil or *HistoryProcessApiCreateCommentOpts - Optional Parameters:
     * @param "Body" (optional.Interface of CommentResponse) - 
@return CommentResponse
*/

type HistoryProcessApiCreateCommentOpts struct {
    Body optional.Interface
}

func (a *HistoryProcessApiService) CreateComment(ctx context.Context, processInstanceId string, localVarOptionals *HistoryProcessApiCreateCommentOpts) (CommentResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CommentResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/history/historic-process-instances/{processInstanceId}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"processInstanceId"+"}", fmt.Sprintf("%v", processInstanceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v CommentResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryProcessApiService Delete a comment on a historic process instance
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param processInstanceId
 * @param commentId

*/
func (a *HistoryProcessApiService) DeleteComment(ctx context.Context, processInstanceId string, commentId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/history/historic-process-instances/{processInstanceId}/comments/{commentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"processInstanceId"+"}", fmt.Sprintf("%v", processInstanceId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", fmt.Sprintf("%v", commentId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
HistoryProcessApiService  Delete a historic process instance
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param processInstanceId

*/
func (a *HistoryProcessApiService) DeleteHistoricProcessInstance(ctx context.Context, processInstanceId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/history/historic-process-instances/{processInstanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"processInstanceId"+"}", fmt.Sprintf("%v", processInstanceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
HistoryProcessApiService Get a comment on a historic process instance
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param processInstanceId
 * @param commentId
@return CommentResponse
*/
func (a *HistoryProcessApiService) GetComment(ctx context.Context, processInstanceId string, commentId string) (CommentResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CommentResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/history/historic-process-instances/{processInstanceId}/comments/{commentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"processInstanceId"+"}", fmt.Sprintf("%v", processInstanceId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", fmt.Sprintf("%v", commentId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v CommentResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryProcessApiService Get a historic process instance
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param processInstanceId
@return HistoricProcessInstanceResponse
*/
func (a *HistoryProcessApiService) GetHistoricProcessInstance(ctx context.Context, processInstanceId string) (HistoricProcessInstanceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue HistoricProcessInstanceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/history/historic-process-instances/{processInstanceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"processInstanceId"+"}", fmt.Sprintf("%v", processInstanceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v HistoricProcessInstanceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryProcessApiService Get the binary data for a historic process instance variable
The response body contains the binary value of the variable. When the variable is of type binary, the content-type of the response is set to application/octet-stream, regardless of the content of the variable or the request accept-type header. In case of serializable, application/x-java-serialized-object is used as content-type.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param processInstanceId
 * @param variableName
@return []string
*/
func (a *HistoryProcessApiService) GetHistoricProcessInstanceVariableData(ctx context.Context, processInstanceId string, variableName string) ([]string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/history/historic-process-instances/{processInstanceId}/variables/{variableName}/data"
	localVarPath = strings.Replace(localVarPath, "{"+"processInstanceId"+"}", fmt.Sprintf("%v", processInstanceId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"variableName"+"}", fmt.Sprintf("%v", variableName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryProcessApiService List comments on a historic process instance
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param processInstanceId
@return []CommentResponse
*/
func (a *HistoryProcessApiService) ListHistoricProcessInstanceComments(ctx context.Context, processInstanceId string) ([]CommentResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []CommentResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/history/historic-process-instances/{processInstanceId}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"processInstanceId"+"}", fmt.Sprintf("%v", processInstanceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []CommentResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryProcessApiService List identity links of a historic process instance
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param processInstanceId
@return []HistoricIdentityLinkResponse
*/
func (a *HistoryProcessApiService) ListHistoricProcessInstanceIdentityLinks(ctx context.Context, processInstanceId string) ([]HistoricIdentityLinkResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []HistoricIdentityLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/history/historic-process-instances/{processInstanceId}/identitylinks"
	localVarPath = strings.Replace(localVarPath, "{"+"processInstanceId"+"}", fmt.Sprintf("%v", processInstanceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []HistoricIdentityLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryProcessApiService List of historic process instances
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *HistoryProcessApiListHistoricProcessInstancesOpts - Optional Parameters:
     * @param "ProcessInstanceId" (optional.String) -  An id of the historic process instance.
     * @param "ProcessInstanceName" (optional.String) -  A name of the historic process instance.
     * @param "ProcessInstanceNameLike" (optional.String) -  A name of the historic process instance used in a like query.
     * @param "ProcessInstanceNameLikeIgnoreCase" (optional.String) -  A name of the historic process instance used in a like query ignoring case.
     * @param "ProcessDefinitionKey" (optional.String) -  The process definition key of the historic process instance.
     * @param "ProcessDefinitionId" (optional.String) -  The process definition id of the historic process instance.
     * @param "ProcessDefinitionName" (optional.String) -  The process definition name of the historic process instance.
     * @param "ProcessDefinitionCategory" (optional.String) -  The process definition category of the historic process instance.
     * @param "ProcessDefinitionVersion" (optional.String) -  The process definition version of the historic process instance.
     * @param "DeploymentId" (optional.String) -  The deployment id of the historic process instance.
     * @param "BusinessKey" (optional.String) -  The business key of the historic process instance.
     * @param "BusinessKeyLike" (optional.String) -  Only return instances with a businessKey like this key.
     * @param "ActiveActivityId" (optional.String) -  Only return instances which have an active activity instance with the provided activity id.
     * @param "InvolvedUser" (optional.String) -  An involved user of the historic process instance.
     * @param "Finished" (optional.Bool) -  Indication if the historic process instance is finished.
     * @param "SuperProcessInstanceId" (optional.String) -  An optional parent process id of the historic process instance.
     * @param "ExcludeSubprocesses" (optional.Bool) -  Return only historic process instances which are not sub processes.
     * @param "FinishedAfter" (optional.Time) -  Return only historic process instances that were finished after this date.
     * @param "FinishedBefore" (optional.Time) -  Return only historic process instances that were finished before this date.
     * @param "StartedAfter" (optional.Time) -  Return only historic process instances that were started after this date.
     * @param "StartedBefore" (optional.Time) -  Return only historic process instances that were started before this date.
     * @param "StartedBy" (optional.String) -  Return only historic process instances that were started by this user.
     * @param "IncludeProcessVariables" (optional.Bool) -  An indication if the historic process instance variables should be returned as well.
     * @param "CallbackId" (optional.String) -  Only return instances with the given callbackId.
     * @param "CallbackType" (optional.String) -  Only return instances with the given callbackType.
     * @param "WithoutCallbackId" (optional.Bool) -  Only return instances that do not have a callbackId.
     * @param "TenantId" (optional.String) -  Only return instances with the given tenantId.
     * @param "TenantIdLike" (optional.String) -  Only return instances with a tenantId like the given value.
     * @param "WithoutTenantId" (optional.Bool) -  If true, only returns instances without a tenantId set. If false, the withoutTenantId parameter is ignored. 
@return DataResponseHistoricProcessInstanceResponse
*/

type HistoryProcessApiListHistoricProcessInstancesOpts struct {
    ProcessInstanceId optional.String
    ProcessInstanceName optional.String
    ProcessInstanceNameLike optional.String
    ProcessInstanceNameLikeIgnoreCase optional.String
    ProcessDefinitionKey optional.String
    ProcessDefinitionId optional.String
    ProcessDefinitionName optional.String
    ProcessDefinitionCategory optional.String
    ProcessDefinitionVersion optional.String
    DeploymentId optional.String
    BusinessKey optional.String
    BusinessKeyLike optional.String
    ActiveActivityId optional.String
    InvolvedUser optional.String
    Finished optional.Bool
    SuperProcessInstanceId optional.String
    ExcludeSubprocesses optional.Bool
    FinishedAfter optional.Time
    FinishedBefore optional.Time
    StartedAfter optional.Time
    StartedBefore optional.Time
    StartedBy optional.String
    IncludeProcessVariables optional.Bool
    CallbackId optional.String
    CallbackType optional.String
    WithoutCallbackId optional.Bool
    TenantId optional.String
    TenantIdLike optional.String
    WithoutTenantId optional.Bool
}

func (a *HistoryProcessApiService) ListHistoricProcessInstances(ctx context.Context, localVarOptionals *HistoryProcessApiListHistoricProcessInstancesOpts) (DataResponseHistoricProcessInstanceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseHistoricProcessInstanceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/history/historic-process-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ProcessInstanceId.IsSet() {
		localVarQueryParams.Add("processInstanceId", parameterToString(localVarOptionals.ProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessInstanceName.IsSet() {
		localVarQueryParams.Add("processInstanceName", parameterToString(localVarOptionals.ProcessInstanceName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessInstanceNameLike.IsSet() {
		localVarQueryParams.Add("processInstanceNameLike", parameterToString(localVarOptionals.ProcessInstanceNameLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessInstanceNameLikeIgnoreCase.IsSet() {
		localVarQueryParams.Add("processInstanceNameLikeIgnoreCase", parameterToString(localVarOptionals.ProcessInstanceNameLikeIgnoreCase.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionKey.IsSet() {
		localVarQueryParams.Add("processDefinitionKey", parameterToString(localVarOptionals.ProcessDefinitionKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionId.IsSet() {
		localVarQueryParams.Add("processDefinitionId", parameterToString(localVarOptionals.ProcessDefinitionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionName.IsSet() {
		localVarQueryParams.Add("processDefinitionName", parameterToString(localVarOptionals.ProcessDefinitionName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionCategory.IsSet() {
		localVarQueryParams.Add("processDefinitionCategory", parameterToString(localVarOptionals.ProcessDefinitionCategory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionVersion.IsSet() {
		localVarQueryParams.Add("processDefinitionVersion", parameterToString(localVarOptionals.ProcessDefinitionVersion.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeploymentId.IsSet() {
		localVarQueryParams.Add("deploymentId", parameterToString(localVarOptionals.DeploymentId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BusinessKey.IsSet() {
		localVarQueryParams.Add("businessKey", parameterToString(localVarOptionals.BusinessKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.BusinessKeyLike.IsSet() {
		localVarQueryParams.Add("businessKeyLike", parameterToString(localVarOptionals.BusinessKeyLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ActiveActivityId.IsSet() {
		localVarQueryParams.Add("activeActivityId", parameterToString(localVarOptionals.ActiveActivityId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InvolvedUser.IsSet() {
		localVarQueryParams.Add("involvedUser", parameterToString(localVarOptionals.InvolvedUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Finished.IsSet() {
		localVarQueryParams.Add("finished", parameterToString(localVarOptionals.Finished.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SuperProcessInstanceId.IsSet() {
		localVarQueryParams.Add("superProcessInstanceId", parameterToString(localVarOptionals.SuperProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeSubprocesses.IsSet() {
		localVarQueryParams.Add("excludeSubprocesses", parameterToString(localVarOptionals.ExcludeSubprocesses.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FinishedAfter.IsSet() {
		localVarQueryParams.Add("finishedAfter", parameterToString(localVarOptionals.FinishedAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FinishedBefore.IsSet() {
		localVarQueryParams.Add("finishedBefore", parameterToString(localVarOptionals.FinishedBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartedAfter.IsSet() {
		localVarQueryParams.Add("startedAfter", parameterToString(localVarOptionals.StartedAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartedBefore.IsSet() {
		localVarQueryParams.Add("startedBefore", parameterToString(localVarOptionals.StartedBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartedBy.IsSet() {
		localVarQueryParams.Add("startedBy", parameterToString(localVarOptionals.StartedBy.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeProcessVariables.IsSet() {
		localVarQueryParams.Add("includeProcessVariables", parameterToString(localVarOptionals.IncludeProcessVariables.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CallbackId.IsSet() {
		localVarQueryParams.Add("callbackId", parameterToString(localVarOptionals.CallbackId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CallbackType.IsSet() {
		localVarQueryParams.Add("callbackType", parameterToString(localVarOptionals.CallbackType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutCallbackId.IsSet() {
		localVarQueryParams.Add("withoutCallbackId", parameterToString(localVarOptionals.WithoutCallbackId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenantId", parameterToString(localVarOptionals.TenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdLike.IsSet() {
		localVarQueryParams.Add("tenantIdLike", parameterToString(localVarOptionals.TenantIdLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutTenantId.IsSet() {
		localVarQueryParams.Add("withoutTenantId", parameterToString(localVarOptionals.WithoutTenantId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseHistoricProcessInstanceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryProcessApiService Query for historic process instances
All supported JSON parameter fields allowed are exactly the same as the parameters found for getting a collection of historic process instances, but passed in as JSON-body arguments rather than URL-parameters to allow for more advanced querying and preventing errors with request-uri’s that are too long. On top of that, the query allows for filtering based on process variables. The variables property is a JSON-array containing objects with the format as described here.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *HistoryProcessApiQueryHistoricProcessInstanceOpts - Optional Parameters:
     * @param "Body" (optional.Interface of HistoricProcessInstanceQueryRequest) - 
@return DataResponseHistoricProcessInstanceResponse
*/

type HistoryProcessApiQueryHistoricProcessInstanceOpts struct {
    Body optional.Interface
}

func (a *HistoryProcessApiService) QueryHistoricProcessInstance(ctx context.Context, localVarOptionals *HistoryProcessApiQueryHistoricProcessInstanceOpts) (DataResponseHistoricProcessInstanceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseHistoricProcessInstanceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/query/historic-process-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseHistoricProcessInstanceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
