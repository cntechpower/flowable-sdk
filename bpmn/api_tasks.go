
/*
 * Flowable REST API
 *
 * # flowable / flowəb(ə)l /    - a compact and highly efficient workflow and Business Process Management (BPM) platform for developers, system admins and business users.  - a lightning fast, tried and tested BPMN 2 process engine written in Java. It is Apache 2.0 licensed open source, with a committed community.  - can run embedded in a Java application, or as a service on a server, a cluster, and in the cloud. It integrates perfectly with Spring. With a rich Java and REST API, it is the ideal engine for orchestrating human or system activities.
 *
 * API version: v1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package bpmn

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type TasksApiService service
/*
TasksApiService Update Tasks
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TasksApiBulkUpdateTasksOpts - Optional Parameters:
     * @param "Body" (optional.Interface of BulkTasksRequest) - 
@return DataResponseTaskResponse
*/

type TasksApiBulkUpdateTasksOpts struct {
    Body optional.Interface
}

func (a *TasksApiService) BulkUpdateTasks(ctx context.Context, localVarOptionals *TasksApiBulkUpdateTasksOpts) (DataResponseTaskResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseTaskResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseTaskResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TasksApiService Create Task
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TasksApiCreateTaskOpts - Optional Parameters:
     * @param "Body" (optional.Interface of TaskRequest) - 
@return TaskResponse
*/

type TasksApiCreateTaskOpts struct {
    Body optional.Interface
}

func (a *TasksApiService) CreateTask(ctx context.Context, localVarOptionals *TasksApiCreateTaskOpts) (TaskResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue TaskResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v TaskResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TasksApiService Create new variables on a task
This endpoint can be used in 2 ways: By passing a JSON Body (RestVariable or an Array of RestVariable) or by passing a multipart/form-data Object. It is possible to create simple (non-binary) variable or list of variables or new binary variable  Any number of variables can be passed into the request body array. NB: Swagger V2 specification does not support this use case that is why this endpoint might be buggy/incomplete if used with other tools.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taskId
 * @param optional nil or *TasksApiCreateTaskVariableOpts - Optional Parameters:
     * @param "Body" (optional.Interface of TaskIdVariablesBody) - 
@return interface{}
*/

type TasksApiCreateTaskVariableOpts struct {
    Body optional.Interface
}

func (a *TasksApiService) CreateTaskVariable(ctx context.Context, taskId string, localVarOptionals *TasksApiCreateTaskVariableOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/tasks/{taskId}/variables"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", fmt.Sprintf("%v", taskId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TasksApiService Delete all local variables on a task
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taskId

*/
func (a *TasksApiService) DeleteAllLocalTaskVariables(ctx context.Context, taskId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/tasks/{taskId}/variables"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", fmt.Sprintf("%v", taskId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
TasksApiService Delete an event on a task
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taskId
 * @param eventId

*/
func (a *TasksApiService) DeleteEvent(ctx context.Context, taskId string, eventId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/tasks/{taskId}/events/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", fmt.Sprintf("%v", taskId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", fmt.Sprintf("%v", eventId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
TasksApiService Delete a task
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taskId
 * @param optional nil or *TasksApiDeleteTaskOpts - Optional Parameters:
     * @param "CascadeHistory" (optional.String) -  Whether or not to delete the HistoricTask instance when deleting the task (if applicable). If not provided, this value defaults to false.
     * @param "DeleteReason" (optional.String) -  Reason why the task is deleted. This value is ignored when cascadeHistory is true.

*/

type TasksApiDeleteTaskOpts struct {
    CascadeHistory optional.String
    DeleteReason optional.String
}

func (a *TasksApiService) DeleteTask(ctx context.Context, taskId string, localVarOptionals *TasksApiDeleteTaskOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/tasks/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", fmt.Sprintf("%v", taskId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.CascadeHistory.IsSet() {
		localVarQueryParams.Add("cascadeHistory", parameterToString(localVarOptionals.CascadeHistory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DeleteReason.IsSet() {
		localVarQueryParams.Add("deleteReason", parameterToString(localVarOptionals.DeleteReason.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
TasksApiService Tasks actions
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taskId
 * @param optional nil or *TasksApiExecuteTaskActionOpts - Optional Parameters:
     * @param "Body" (optional.Interface of TaskActionRequest) - 

*/

type TasksApiExecuteTaskActionOpts struct {
    Body optional.Interface
}

func (a *TasksApiService) ExecuteTaskAction(ctx context.Context, taskId string, localVarOptionals *TasksApiExecuteTaskActionOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/tasks/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", fmt.Sprintf("%v", taskId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
TasksApiService Get an event on a task
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taskId
 * @param eventId
@return EventResponse
*/
func (a *TasksApiService) GetEvent(ctx context.Context, taskId string, eventId string) (EventResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue EventResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/tasks/{taskId}/events/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", fmt.Sprintf("%v", taskId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", fmt.Sprintf("%v", eventId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v EventResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TasksApiService Get a task
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taskId
@return TaskResponse
*/
func (a *TasksApiService) GetTask(ctx context.Context, taskId string) (TaskResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue TaskResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/tasks/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", fmt.Sprintf("%v", taskId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v TaskResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TasksApiService Get a task form
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taskId
@return string
*/
func (a *TasksApiService) GetTaskForm(ctx context.Context, taskId string) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/tasks/{taskId}/form"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", fmt.Sprintf("%v", taskId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TasksApiService List events for a task
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taskId
@return []EventResponse
*/
func (a *TasksApiService) ListTaskEvents(ctx context.Context, taskId string) ([]EventResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []EventResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/tasks/{taskId}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", fmt.Sprintf("%v", taskId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []EventResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TasksApiService List of sub tasks for a task
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taskId
@return []TaskResponse
*/
func (a *TasksApiService) ListTaskSubtasks(ctx context.Context, taskId string) ([]TaskResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []TaskResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/tasks/{taskId}/subtasks"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", fmt.Sprintf("%v", taskId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []TaskResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TasksApiService List of tasks
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TasksApiListTasksOpts - Optional Parameters:
     * @param "Name" (optional.String) -  Only return models with the given version.
     * @param "NameLike" (optional.String) -  Only return tasks with a name like the given name.
     * @param "Description" (optional.String) -  Only return tasks with the given description.
     * @param "Priority" (optional.String) -  Only return tasks with the given priority.
     * @param "MinimumPriority" (optional.String) -  Only return tasks with a priority greater than the given value.
     * @param "MaximumPriority" (optional.String) -  Only return tasks with a priority lower than the given value.
     * @param "Assignee" (optional.String) -  Only return tasks assigned to the given user.
     * @param "AssigneeLike" (optional.String) -  Only return tasks assigned with an assignee like the given value.
     * @param "Owner" (optional.String) -  Only return tasks owned by the given user.
     * @param "OwnerLike" (optional.String) -  Only return tasks assigned with an owner like the given value.
     * @param "Unassigned" (optional.String) -  Only return tasks that are not assigned to anyone. If false is passed, the value is ignored.
     * @param "DelegationState" (optional.String) -  Only return tasks that have the given delegation state. Possible values are pending and resolved.
     * @param "CandidateUser" (optional.String) -  Only return tasks that can be claimed by the given user. This includes both tasks where the user is an explicit candidate for and task that are claimable by a group that the user is a member of.
     * @param "CandidateGroup" (optional.String) -  Only return tasks that can be claimed by a user in the given group.
     * @param "CandidateGroups" (optional.String) -  Only return tasks that can be claimed by a user in the given groups. Values split by comma.
     * @param "InvolvedUser" (optional.String) -  Only return tasks in which the given user is involved.
     * @param "TaskDefinitionKey" (optional.String) -  Only return tasks with the given task definition id.
     * @param "TaskDefinitionKeyLike" (optional.String) -  Only return tasks with a given task definition id like the given value.
     * @param "TaskDefinitionKeys" (optional.String) -  Only return tasks with the given task definition ids.
     * @param "ProcessInstanceId" (optional.String) -  Only return tasks which are part of the process instance with the given id.
     * @param "ProcessInstanceIdWithChildren" (optional.String) -  Only return tasks which are part of the process instance and its children with the given id.
     * @param "WithoutProcessInstanceId" (optional.Bool) -  If true, only returns tasks without a process instance id set. If false, the withoutProcessInstanceId parameter is ignored.
     * @param "ProcessInstanceBusinessKey" (optional.String) -  Only return tasks which are part of the process instance with the given business key.
     * @param "ProcessInstanceBusinessKeyLike" (optional.String) -  Only return tasks which are part of the process instance which has a business key like the given value.
     * @param "ProcessDefinitionId" (optional.String) -  Only return tasks which are part of a process instance which has a process definition with the given id.
     * @param "ProcessDefinitionKey" (optional.String) -  Only return tasks which are part of a process instance which has a process definition with the given key.
     * @param "ProcessDefinitionKeyLike" (optional.String) -  Only return tasks which are part of a process instance which has a process definition with a key like the given value.
     * @param "ProcessDefinitionName" (optional.String) -  Only return tasks which are part of a process instance which has a process definition with the given name.
     * @param "ProcessDefinitionNameLike" (optional.String) -  Only return tasks which are part of a process instance which has a process definition with a name like the given value.
     * @param "ExecutionId" (optional.String) -  Only return tasks which are part of the execution with the given id.
     * @param "CreatedOn" (optional.Time) -  Only return tasks which are created on the given date.
     * @param "CreatedBefore" (optional.Time) -  Only return tasks which are created before the given date.
     * @param "CreatedAfter" (optional.Time) -  Only return tasks which are created after the given date.
     * @param "DueDate" (optional.Time) -  Only return tasks which are due on the given date.
     * @param "DueBefore" (optional.Time) -  Only return tasks which are due before the given date.
     * @param "DueAfter" (optional.Time) -  Only return tasks which are due after the given date.
     * @param "WithoutDueDate" (optional.Bool) -  Only return tasks which do not have a due date. The property is ignored if the value is false.
     * @param "ExcludeSubTasks" (optional.Bool) -  Only return tasks that are not a subtask of another task.
     * @param "Active" (optional.Bool) -  If true, only return tasks that are not suspended (either part of a process that is not suspended or not part of a process at all). If false, only tasks that are part of suspended process instances are returned.
     * @param "IncludeTaskLocalVariables" (optional.Bool) -  Indication to include task local variables in the result.
     * @param "IncludeProcessVariables" (optional.Bool) -  Indication to include process variables in the result.
     * @param "ScopeDefinitionId" (optional.String) -  Only return tasks with the given scopeDefinitionId.
     * @param "ScopeId" (optional.String) -  Only return tasks with the given scopeId.
     * @param "WithoutScopeId" (optional.Bool) -  If true, only returns tasks without a scope id set. If false, the withoutScopeId parameter is ignored.
     * @param "ScopeType" (optional.String) -  Only return tasks with the given scopeType.
     * @param "PropagatedStageInstanceId" (optional.String) -  Only return tasks which have the given id as propagated stage instance id
     * @param "TenantId" (optional.String) -  Only return tasks with the given tenantId.
     * @param "TenantIdLike" (optional.String) -  Only return tasks with a tenantId like the given value.
     * @param "WithoutTenantId" (optional.Bool) -  If true, only returns tasks without a tenantId set. If false, the withoutTenantId parameter is ignored.
     * @param "CandidateOrAssigned" (optional.String) -  Select tasks that has been claimed or assigned to user or waiting to claim by user (candidate user or groups).
     * @param "Category" (optional.String) -  Select tasks with the given category. Note that this is the task category, not the category of the process definition (namespace within the BPMN Xml). 
     * @param "CategoryIn" (optional.String) -  Select tasks for the given categories. Note that this is the task category, not the category of the process definition (namespace within the BPMN Xml). 
     * @param "CategoryNotIn" (optional.String) -  Select tasks which are not assigned to the given categories. Does not return tasks without categories. Note that this is the task category, not the category of the process definition (namespace within the BPMN Xml). 
     * @param "WithoutCategory" (optional.String) -  Select tasks without a category assigned. Note that this is the task category, not the category of the process definition (namespace within the BPMN Xml). 
@return DataResponseTaskResponse
*/

type TasksApiListTasksOpts struct {
    Name optional.String
    NameLike optional.String
    Description optional.String
    Priority optional.String
    MinimumPriority optional.String
    MaximumPriority optional.String
    Assignee optional.String
    AssigneeLike optional.String
    Owner optional.String
    OwnerLike optional.String
    Unassigned optional.String
    DelegationState optional.String
    CandidateUser optional.String
    CandidateGroup optional.String
    CandidateGroups optional.String
    InvolvedUser optional.String
    TaskDefinitionKey optional.String
    TaskDefinitionKeyLike optional.String
    TaskDefinitionKeys optional.String
    ProcessInstanceId optional.String
    ProcessInstanceIdWithChildren optional.String
    WithoutProcessInstanceId optional.Bool
    ProcessInstanceBusinessKey optional.String
    ProcessInstanceBusinessKeyLike optional.String
    ProcessDefinitionId optional.String
    ProcessDefinitionKey optional.String
    ProcessDefinitionKeyLike optional.String
    ProcessDefinitionName optional.String
    ProcessDefinitionNameLike optional.String
    ExecutionId optional.String
    CreatedOn optional.Time
    CreatedBefore optional.Time
    CreatedAfter optional.Time
    DueDate optional.Time
    DueBefore optional.Time
    DueAfter optional.Time
    WithoutDueDate optional.Bool
    ExcludeSubTasks optional.Bool
    Active optional.Bool
    IncludeTaskLocalVariables optional.Bool
    IncludeProcessVariables optional.Bool
    ScopeDefinitionId optional.String
    ScopeId optional.String
    WithoutScopeId optional.Bool
    ScopeType optional.String
    PropagatedStageInstanceId optional.String
    TenantId optional.String
    TenantIdLike optional.String
    WithoutTenantId optional.Bool
    CandidateOrAssigned optional.String
    Category optional.String
    CategoryIn optional.String
    CategoryNotIn optional.String
    WithoutCategory optional.String
}

func (a *TasksApiService) ListTasks(ctx context.Context, localVarOptionals *TasksApiListTasksOpts) (DataResponseTaskResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseTaskResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Name.IsSet() {
		localVarQueryParams.Add("name", parameterToString(localVarOptionals.Name.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.NameLike.IsSet() {
		localVarQueryParams.Add("nameLike", parameterToString(localVarOptionals.NameLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Description.IsSet() {
		localVarQueryParams.Add("description", parameterToString(localVarOptionals.Description.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Priority.IsSet() {
		localVarQueryParams.Add("priority", parameterToString(localVarOptionals.Priority.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MinimumPriority.IsSet() {
		localVarQueryParams.Add("minimumPriority", parameterToString(localVarOptionals.MinimumPriority.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaximumPriority.IsSet() {
		localVarQueryParams.Add("maximumPriority", parameterToString(localVarOptionals.MaximumPriority.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Assignee.IsSet() {
		localVarQueryParams.Add("assignee", parameterToString(localVarOptionals.Assignee.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AssigneeLike.IsSet() {
		localVarQueryParams.Add("assigneeLike", parameterToString(localVarOptionals.AssigneeLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Owner.IsSet() {
		localVarQueryParams.Add("owner", parameterToString(localVarOptionals.Owner.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.OwnerLike.IsSet() {
		localVarQueryParams.Add("ownerLike", parameterToString(localVarOptionals.OwnerLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Unassigned.IsSet() {
		localVarQueryParams.Add("unassigned", parameterToString(localVarOptionals.Unassigned.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DelegationState.IsSet() {
		localVarQueryParams.Add("delegationState", parameterToString(localVarOptionals.DelegationState.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CandidateUser.IsSet() {
		localVarQueryParams.Add("candidateUser", parameterToString(localVarOptionals.CandidateUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CandidateGroup.IsSet() {
		localVarQueryParams.Add("candidateGroup", parameterToString(localVarOptionals.CandidateGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CandidateGroups.IsSet() {
		localVarQueryParams.Add("candidateGroups", parameterToString(localVarOptionals.CandidateGroups.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.InvolvedUser.IsSet() {
		localVarQueryParams.Add("involvedUser", parameterToString(localVarOptionals.InvolvedUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskDefinitionKey.IsSet() {
		localVarQueryParams.Add("taskDefinitionKey", parameterToString(localVarOptionals.TaskDefinitionKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskDefinitionKeyLike.IsSet() {
		localVarQueryParams.Add("taskDefinitionKeyLike", parameterToString(localVarOptionals.TaskDefinitionKeyLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskDefinitionKeys.IsSet() {
		localVarQueryParams.Add("taskDefinitionKeys", parameterToString(localVarOptionals.TaskDefinitionKeys.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessInstanceId.IsSet() {
		localVarQueryParams.Add("processInstanceId", parameterToString(localVarOptionals.ProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessInstanceIdWithChildren.IsSet() {
		localVarQueryParams.Add("processInstanceIdWithChildren", parameterToString(localVarOptionals.ProcessInstanceIdWithChildren.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutProcessInstanceId.IsSet() {
		localVarQueryParams.Add("withoutProcessInstanceId", parameterToString(localVarOptionals.WithoutProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessInstanceBusinessKey.IsSet() {
		localVarQueryParams.Add("processInstanceBusinessKey", parameterToString(localVarOptionals.ProcessInstanceBusinessKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessInstanceBusinessKeyLike.IsSet() {
		localVarQueryParams.Add("processInstanceBusinessKeyLike", parameterToString(localVarOptionals.ProcessInstanceBusinessKeyLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionId.IsSet() {
		localVarQueryParams.Add("processDefinitionId", parameterToString(localVarOptionals.ProcessDefinitionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionKey.IsSet() {
		localVarQueryParams.Add("processDefinitionKey", parameterToString(localVarOptionals.ProcessDefinitionKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionKeyLike.IsSet() {
		localVarQueryParams.Add("processDefinitionKeyLike", parameterToString(localVarOptionals.ProcessDefinitionKeyLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionName.IsSet() {
		localVarQueryParams.Add("processDefinitionName", parameterToString(localVarOptionals.ProcessDefinitionName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionNameLike.IsSet() {
		localVarQueryParams.Add("processDefinitionNameLike", parameterToString(localVarOptionals.ProcessDefinitionNameLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExecutionId.IsSet() {
		localVarQueryParams.Add("executionId", parameterToString(localVarOptionals.ExecutionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedOn.IsSet() {
		localVarQueryParams.Add("createdOn", parameterToString(localVarOptionals.CreatedOn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedBefore.IsSet() {
		localVarQueryParams.Add("createdBefore", parameterToString(localVarOptionals.CreatedBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedAfter.IsSet() {
		localVarQueryParams.Add("createdAfter", parameterToString(localVarOptionals.CreatedAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DueDate.IsSet() {
		localVarQueryParams.Add("dueDate", parameterToString(localVarOptionals.DueDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DueBefore.IsSet() {
		localVarQueryParams.Add("dueBefore", parameterToString(localVarOptionals.DueBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DueAfter.IsSet() {
		localVarQueryParams.Add("dueAfter", parameterToString(localVarOptionals.DueAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutDueDate.IsSet() {
		localVarQueryParams.Add("withoutDueDate", parameterToString(localVarOptionals.WithoutDueDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExcludeSubTasks.IsSet() {
		localVarQueryParams.Add("excludeSubTasks", parameterToString(localVarOptionals.ExcludeSubTasks.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Active.IsSet() {
		localVarQueryParams.Add("active", parameterToString(localVarOptionals.Active.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeTaskLocalVariables.IsSet() {
		localVarQueryParams.Add("includeTaskLocalVariables", parameterToString(localVarOptionals.IncludeTaskLocalVariables.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeProcessVariables.IsSet() {
		localVarQueryParams.Add("includeProcessVariables", parameterToString(localVarOptionals.IncludeProcessVariables.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeDefinitionId.IsSet() {
		localVarQueryParams.Add("scopeDefinitionId", parameterToString(localVarOptionals.ScopeDefinitionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeId.IsSet() {
		localVarQueryParams.Add("scopeId", parameterToString(localVarOptionals.ScopeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutScopeId.IsSet() {
		localVarQueryParams.Add("withoutScopeId", parameterToString(localVarOptionals.WithoutScopeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeType.IsSet() {
		localVarQueryParams.Add("scopeType", parameterToString(localVarOptionals.ScopeType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PropagatedStageInstanceId.IsSet() {
		localVarQueryParams.Add("propagatedStageInstanceId", parameterToString(localVarOptionals.PropagatedStageInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenantId", parameterToString(localVarOptionals.TenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdLike.IsSet() {
		localVarQueryParams.Add("tenantIdLike", parameterToString(localVarOptionals.TenantIdLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutTenantId.IsSet() {
		localVarQueryParams.Add("withoutTenantId", parameterToString(localVarOptionals.WithoutTenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CandidateOrAssigned.IsSet() {
		localVarQueryParams.Add("candidateOrAssigned", parameterToString(localVarOptionals.CandidateOrAssigned.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Category.IsSet() {
		localVarQueryParams.Add("category", parameterToString(localVarOptionals.Category.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CategoryIn.IsSet() {
		localVarQueryParams.Add("categoryIn", parameterToString(localVarOptionals.CategoryIn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CategoryNotIn.IsSet() {
		localVarQueryParams.Add("categoryNotIn", parameterToString(localVarOptionals.CategoryNotIn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutCategory.IsSet() {
		localVarQueryParams.Add("withoutCategory", parameterToString(localVarOptionals.WithoutCategory.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseTaskResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TasksApiService Query for tasks
All supported JSON parameter fields allowed are exactly the same as the parameters found for getting a collection of tasks (except for candidateGroupIn which is only available in this POST task query REST service), but passed in as JSON-body arguments rather than URL-parameters to allow for more advanced querying and preventing errors with request-uri’s that are too long. On top of that, the query allows for filtering based on task and process variables. The taskVariables and processInstanceVariables are both JSON-arrays containing objects with the format as described here.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *TasksApiQueryTasksOpts - Optional Parameters:
     * @param "Body" (optional.Interface of TaskQueryRequest) - 
@return DataResponseTaskResponse
*/

type TasksApiQueryTasksOpts struct {
    Body optional.Interface
}

func (a *TasksApiService) QueryTasks(ctx context.Context, localVarOptionals *TasksApiQueryTasksOpts) (DataResponseTaskResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseTaskResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/query/tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseTaskResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
TasksApiService Update a task
All request values are optional. For example, you can only include the assignee attribute in the request body JSON-object, only updating the assignee of the task, leaving all other fields unaffected. When an attribute is explicitly included and is set to null, the task-value will be updated to null. Example: {\&quot;dueDate\&quot; : null} will clear the duedate of the task).
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taskId
 * @param optional nil or *TasksApiUpdateTaskOpts - Optional Parameters:
     * @param "Body" (optional.Interface of TaskRequest) - 
@return TaskResponse
*/

type TasksApiUpdateTaskOpts struct {
    Body optional.Interface
}

func (a *TasksApiService) UpdateTask(ctx context.Context, taskId string, localVarOptionals *TasksApiUpdateTaskOpts) (TaskResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue TaskResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/tasks/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", fmt.Sprintf("%v", taskId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v TaskResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
