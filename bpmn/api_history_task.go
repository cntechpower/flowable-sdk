
/*
 * Flowable REST API
 *
 * # flowable / flowəb(ə)l /    - a compact and highly efficient workflow and Business Process Management (BPM) platform for developers, system admins and business users.  - a lightning fast, tried and tested BPMN 2 process engine written in Java. It is Apache 2.0 licensed open source, with a committed community.  - can run embedded in a Java application, or as a service on a server, a cluster, and in the cloud. It integrates perfectly with Spring. With a rich Java and REST API, it is the ideal engine for orchestrating human or system activities.
 *
 * API version: v1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package bpmn

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type HistoryTaskApiService service
/*
HistoryTaskApiService Delete a historic task instance
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taskId

*/
func (a *HistoryTaskApiService) DeleteTaskInstance(ctx context.Context, taskId string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/history/historic-task-instances/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", fmt.Sprintf("%v", taskId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
/*
HistoryTaskApiService Get a historic task instance form
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taskId
@return string
*/
func (a *HistoryTaskApiService) GetHistoricTaskForm(ctx context.Context, taskId string) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/history/historic-task-instances/{taskId}/form"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", fmt.Sprintf("%v", taskId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryTaskApiService List historic task log entries
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *HistoryTaskApiGetHistoricTaskLogEntriesOpts - Optional Parameters:
     * @param "TaskId" (optional.String) -  An id of the historic task instance.
     * @param "Type_" (optional.String) -  The type of the log entry.
     * @param "UserId" (optional.String) -  The user who produced the task change.
     * @param "ProcessInstanceId" (optional.String) -  The process instance id of the historic task log entry.
     * @param "ProcessDefinitionId" (optional.String) -  The process definition id of the historic task log entry.
     * @param "ScopeId" (optional.String) -  Only return historic task log entries with the given scopeId.
     * @param "ScopeDefinitionId" (optional.String) -  Only return historic task log entries with the given scopeDefinitionId.
     * @param "SubScopeId" (optional.String) -  Only return historic task log entries with the given subScopeId
     * @param "ScopeType" (optional.String) -  Only return historic task log entries with the given scopeType.
     * @param "From" (optional.Time) -  Return task log entries starting from a date.
     * @param "To" (optional.Time) -  Return task log entries up to a date.
     * @param "TenantId" (optional.String) -  Only return historic task log entries with the given tenantId.
     * @param "FromLogNumber" (optional.String) -  Return task log entries starting from a log number
     * @param "ToLogNumber" (optional.String) -  Return task log entries up to specific a log number
@return DataResponseHistoricTaskLogEntryResponse
*/

type HistoryTaskApiGetHistoricTaskLogEntriesOpts struct {
    TaskId optional.String
    Type_ optional.String
    UserId optional.String
    ProcessInstanceId optional.String
    ProcessDefinitionId optional.String
    ScopeId optional.String
    ScopeDefinitionId optional.String
    SubScopeId optional.String
    ScopeType optional.String
    From optional.Time
    To optional.Time
    TenantId optional.String
    FromLogNumber optional.String
    ToLogNumber optional.String
}

func (a *HistoryTaskApiService) GetHistoricTaskLogEntries(ctx context.Context, localVarOptionals *HistoryTaskApiGetHistoricTaskLogEntriesOpts) (DataResponseHistoricTaskLogEntryResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseHistoricTaskLogEntryResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/history/historic-task-log-entries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.TaskId.IsSet() {
		localVarQueryParams.Add("taskId", parameterToString(localVarOptionals.TaskId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Type_.IsSet() {
		localVarQueryParams.Add("type", parameterToString(localVarOptionals.Type_.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.UserId.IsSet() {
		localVarQueryParams.Add("userId", parameterToString(localVarOptionals.UserId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessInstanceId.IsSet() {
		localVarQueryParams.Add("processInstanceId", parameterToString(localVarOptionals.ProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionId.IsSet() {
		localVarQueryParams.Add("processDefinitionId", parameterToString(localVarOptionals.ProcessDefinitionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeId.IsSet() {
		localVarQueryParams.Add("scopeId", parameterToString(localVarOptionals.ScopeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeDefinitionId.IsSet() {
		localVarQueryParams.Add("scopeDefinitionId", parameterToString(localVarOptionals.ScopeDefinitionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubScopeId.IsSet() {
		localVarQueryParams.Add("subScopeId", parameterToString(localVarOptionals.SubScopeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeType.IsSet() {
		localVarQueryParams.Add("scopeType", parameterToString(localVarOptionals.ScopeType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.From.IsSet() {
		localVarQueryParams.Add("from", parameterToString(localVarOptionals.From.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.To.IsSet() {
		localVarQueryParams.Add("to", parameterToString(localVarOptionals.To.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenantId", parameterToString(localVarOptionals.TenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FromLogNumber.IsSet() {
		localVarQueryParams.Add("fromLogNumber", parameterToString(localVarOptionals.FromLogNumber.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ToLogNumber.IsSet() {
		localVarQueryParams.Add("toLogNumber", parameterToString(localVarOptionals.ToLogNumber.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseHistoricTaskLogEntryResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryTaskApiService Get a single historic task instance
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taskId
@return HistoricTaskInstanceResponse
*/
func (a *HistoryTaskApiService) GetTaskInstance(ctx context.Context, taskId string) (HistoricTaskInstanceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue HistoricTaskInstanceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/history/historic-task-instances/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", fmt.Sprintf("%v", taskId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v HistoricTaskInstanceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryTaskApiService List identity links of a historic task instance
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param taskId
@return []HistoricIdentityLinkResponse
*/
func (a *HistoryTaskApiService) ListHistoricTaskInstanceIdentityLinks(ctx context.Context, taskId string) ([]HistoricIdentityLinkResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []HistoricIdentityLinkResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/history/historic-task-instances/{taskId}/identitylinks"
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", fmt.Sprintf("%v", taskId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v []HistoricIdentityLinkResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryTaskApiService List historic task instances
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *HistoryTaskApiListHistoricTaskInstancesOpts - Optional Parameters:
     * @param "TaskId" (optional.String) -  An id of the historic task instance.
     * @param "ProcessInstanceId" (optional.String) -  The process instance id of the historic task instance.
     * @param "ProcessInstanceIdWithChildren" (optional.String) -  Selects the historic task instances for the process instance and its children.
     * @param "WithoutProcessInstanceId" (optional.Bool) -  If true, only returns historic task instances without a process instance id set. If false, the withoutProcessInstanceId parameter is ignored.
     * @param "ProcessDefinitionKey" (optional.String) -  The process definition key of the historic task instance.
     * @param "ProcessDefinitionKeyLike" (optional.String) -  The process definition key of the historic task instance, which matches the given value.
     * @param "ProcessDefinitionId" (optional.String) -  The process definition id of the historic task instance.
     * @param "ProcessDefinitionName" (optional.String) -  The process definition name of the historic task instance.
     * @param "ProcessDefinitionNameLike" (optional.String) -  The process definition name of the historic task instance, which matches the given value.
     * @param "ProcessBusinessKey" (optional.String) -  The process instance business key of the historic task instance.
     * @param "ProcessBusinessKeyLike" (optional.String) -  The process instance business key of the historic task instance that matches the given value.
     * @param "ExecutionId" (optional.String) -  The execution id of the historic task instance.
     * @param "TaskDefinitionKey" (optional.String) -  The task definition key for tasks part of a process
     * @param "TaskDefinitionKeys" (optional.String) -  The task definition key for tasks part of a process
     * @param "TaskName" (optional.String) -  The task name of the historic task instance.
     * @param "TaskNameLike" (optional.String) -  The task name with like operator for the historic task instance.
     * @param "TaskDescription" (optional.String) -  The task description of the historic task instance.
     * @param "TaskDescriptionLike" (optional.String) -  The task description with like operator for the historic task instance.
     * @param "TaskCategory" (optional.String) -  Select tasks with the given category. Note that this is the task category, not the category of the process definition (namespace within the BPMN Xml).
     * @param "TaskCategoryIn" (optional.String) -  Select tasks with the given categories. Note that this is the task category, not the category of the process definition (namespace within the BPMN Xml).
     * @param "TaskCategoryNotIn" (optional.String) -  Select tasks not assigned to the given categories. Note that this is the task category, not the category of the process definition (namespace within the BPMN Xml).
     * @param "TaskWithoutCategory" (optional.String) -  Select tasks with no category assigned. Note that this is the task category, not the category of the process definition (namespace within the BPMN Xml).
     * @param "TaskDeleteReason" (optional.String) -  The task delete reason of the historic task instance.
     * @param "TaskDeleteReasonLike" (optional.String) -  The task delete reason with like operator for the historic task instance.
     * @param "TaskAssignee" (optional.String) -  The assignee of the historic task instance.
     * @param "TaskAssigneeLike" (optional.String) -  The assignee with like operator for the historic task instance.
     * @param "TaskOwner" (optional.String) -  The owner of the historic task instance.
     * @param "TaskOwnerLike" (optional.String) -  The owner with like operator for the historic task instance.
     * @param "TaskInvolvedUser" (optional.String) -  An involved user of the historic task instance
     * @param "TaskCandidateGroup" (optional.String) -  Only return tasks that can be claimed by a user in the given group.
     * @param "TaskPriority" (optional.String) -  The priority of the historic task instance.
     * @param "Finished" (optional.Bool) -  Indication if the historic task instance is finished.
     * @param "ProcessFinished" (optional.Bool) -  Indication if the process instance of the historic task instance is finished.
     * @param "ParentTaskId" (optional.String) -  An optional parent task id of the historic task instance.
     * @param "DueDate" (optional.Time) -  Return only historic task instances that have a due date equal this date.
     * @param "DueDateAfter" (optional.Time) -  Return only historic task instances that have a due date after this date.
     * @param "DueDateBefore" (optional.Time) -  Return only historic task instances that have a due date before this date.
     * @param "WithoutDueDate" (optional.Bool) -  Return only historic task instances that have no due-date. When false is provided as value, this parameter is ignored.
     * @param "TaskCompletedOn" (optional.Time) -  Return only historic task instances that have been completed on this date.
     * @param "TaskCompletedAfter" (optional.Time) -  Return only historic task instances that have been completed after this date.
     * @param "TaskCompletedBefore" (optional.Time) -  Return only historic task instances that have been completed before this date.
     * @param "TaskCreatedOn" (optional.Time) -  Return only historic task instances that were created on this date.
     * @param "TaskCreatedBefore" (optional.Time) -  Return only historic task instances that were created before this date.
     * @param "TaskCreatedAfter" (optional.Time) -  Return only historic task instances that were created after this date.
     * @param "IncludeTaskLocalVariables" (optional.Bool) -  An indication if the historic task instance local variables should be returned as well.
     * @param "IncludeProcessVariables" (optional.Bool) -  An indication if the historic task instance global variables should be returned as well.
     * @param "ScopeDefinitionId" (optional.String) -  Only return historic task instances with the given scopeDefinitionId.
     * @param "ScopeId" (optional.String) -  Only return historic task instances with the given scopeId.
     * @param "WithoutScopeId" (optional.Bool) -  If true, only returns historic task instances without a scope id set. If false, the withoutScopeId parameter is ignored.
     * @param "ScopeType" (optional.String) -  Only return historic task instances with the given scopeType.
     * @param "PropagatedStageInstanceId" (optional.String) -  Only return tasks which have the given id as propagated stage instance id
     * @param "TenantId" (optional.String) -  Only return historic task instances with the given tenantId.
     * @param "TenantIdLike" (optional.String) -  Only return historic task instances with a tenantId like the given value.
     * @param "WithoutTenantId" (optional.Bool) -  If true, only returns historic task instances without a tenantId set. If false, the withoutTenantId parameter is ignored.
@return DataResponseHistoricTaskInstanceResponse
*/

type HistoryTaskApiListHistoricTaskInstancesOpts struct {
    TaskId optional.String
    ProcessInstanceId optional.String
    ProcessInstanceIdWithChildren optional.String
    WithoutProcessInstanceId optional.Bool
    ProcessDefinitionKey optional.String
    ProcessDefinitionKeyLike optional.String
    ProcessDefinitionId optional.String
    ProcessDefinitionName optional.String
    ProcessDefinitionNameLike optional.String
    ProcessBusinessKey optional.String
    ProcessBusinessKeyLike optional.String
    ExecutionId optional.String
    TaskDefinitionKey optional.String
    TaskDefinitionKeys optional.String
    TaskName optional.String
    TaskNameLike optional.String
    TaskDescription optional.String
    TaskDescriptionLike optional.String
    TaskCategory optional.String
    TaskCategoryIn optional.String
    TaskCategoryNotIn optional.String
    TaskWithoutCategory optional.String
    TaskDeleteReason optional.String
    TaskDeleteReasonLike optional.String
    TaskAssignee optional.String
    TaskAssigneeLike optional.String
    TaskOwner optional.String
    TaskOwnerLike optional.String
    TaskInvolvedUser optional.String
    TaskCandidateGroup optional.String
    TaskPriority optional.String
    Finished optional.Bool
    ProcessFinished optional.Bool
    ParentTaskId optional.String
    DueDate optional.Time
    DueDateAfter optional.Time
    DueDateBefore optional.Time
    WithoutDueDate optional.Bool
    TaskCompletedOn optional.Time
    TaskCompletedAfter optional.Time
    TaskCompletedBefore optional.Time
    TaskCreatedOn optional.Time
    TaskCreatedBefore optional.Time
    TaskCreatedAfter optional.Time
    IncludeTaskLocalVariables optional.Bool
    IncludeProcessVariables optional.Bool
    ScopeDefinitionId optional.String
    ScopeId optional.String
    WithoutScopeId optional.Bool
    ScopeType optional.String
    PropagatedStageInstanceId optional.String
    TenantId optional.String
    TenantIdLike optional.String
    WithoutTenantId optional.Bool
}

func (a *HistoryTaskApiService) ListHistoricTaskInstances(ctx context.Context, localVarOptionals *HistoryTaskApiListHistoricTaskInstancesOpts) (DataResponseHistoricTaskInstanceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseHistoricTaskInstanceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/history/historic-task-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.TaskId.IsSet() {
		localVarQueryParams.Add("taskId", parameterToString(localVarOptionals.TaskId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessInstanceId.IsSet() {
		localVarQueryParams.Add("processInstanceId", parameterToString(localVarOptionals.ProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessInstanceIdWithChildren.IsSet() {
		localVarQueryParams.Add("processInstanceIdWithChildren", parameterToString(localVarOptionals.ProcessInstanceIdWithChildren.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutProcessInstanceId.IsSet() {
		localVarQueryParams.Add("withoutProcessInstanceId", parameterToString(localVarOptionals.WithoutProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionKey.IsSet() {
		localVarQueryParams.Add("processDefinitionKey", parameterToString(localVarOptionals.ProcessDefinitionKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionKeyLike.IsSet() {
		localVarQueryParams.Add("processDefinitionKeyLike", parameterToString(localVarOptionals.ProcessDefinitionKeyLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionId.IsSet() {
		localVarQueryParams.Add("processDefinitionId", parameterToString(localVarOptionals.ProcessDefinitionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionName.IsSet() {
		localVarQueryParams.Add("processDefinitionName", parameterToString(localVarOptionals.ProcessDefinitionName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionNameLike.IsSet() {
		localVarQueryParams.Add("processDefinitionNameLike", parameterToString(localVarOptionals.ProcessDefinitionNameLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessBusinessKey.IsSet() {
		localVarQueryParams.Add("processBusinessKey", parameterToString(localVarOptionals.ProcessBusinessKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessBusinessKeyLike.IsSet() {
		localVarQueryParams.Add("processBusinessKeyLike", parameterToString(localVarOptionals.ProcessBusinessKeyLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExecutionId.IsSet() {
		localVarQueryParams.Add("executionId", parameterToString(localVarOptionals.ExecutionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskDefinitionKey.IsSet() {
		localVarQueryParams.Add("taskDefinitionKey", parameterToString(localVarOptionals.TaskDefinitionKey.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskDefinitionKeys.IsSet() {
		localVarQueryParams.Add("taskDefinitionKeys", parameterToString(localVarOptionals.TaskDefinitionKeys.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskName.IsSet() {
		localVarQueryParams.Add("taskName", parameterToString(localVarOptionals.TaskName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskNameLike.IsSet() {
		localVarQueryParams.Add("taskNameLike", parameterToString(localVarOptionals.TaskNameLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskDescription.IsSet() {
		localVarQueryParams.Add("taskDescription", parameterToString(localVarOptionals.TaskDescription.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskDescriptionLike.IsSet() {
		localVarQueryParams.Add("taskDescriptionLike", parameterToString(localVarOptionals.TaskDescriptionLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskCategory.IsSet() {
		localVarQueryParams.Add("taskCategory", parameterToString(localVarOptionals.TaskCategory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskCategoryIn.IsSet() {
		localVarQueryParams.Add("taskCategoryIn", parameterToString(localVarOptionals.TaskCategoryIn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskCategoryNotIn.IsSet() {
		localVarQueryParams.Add("taskCategoryNotIn", parameterToString(localVarOptionals.TaskCategoryNotIn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskWithoutCategory.IsSet() {
		localVarQueryParams.Add("taskWithoutCategory", parameterToString(localVarOptionals.TaskWithoutCategory.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskDeleteReason.IsSet() {
		localVarQueryParams.Add("taskDeleteReason", parameterToString(localVarOptionals.TaskDeleteReason.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskDeleteReasonLike.IsSet() {
		localVarQueryParams.Add("taskDeleteReasonLike", parameterToString(localVarOptionals.TaskDeleteReasonLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskAssignee.IsSet() {
		localVarQueryParams.Add("taskAssignee", parameterToString(localVarOptionals.TaskAssignee.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskAssigneeLike.IsSet() {
		localVarQueryParams.Add("taskAssigneeLike", parameterToString(localVarOptionals.TaskAssigneeLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskOwner.IsSet() {
		localVarQueryParams.Add("taskOwner", parameterToString(localVarOptionals.TaskOwner.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskOwnerLike.IsSet() {
		localVarQueryParams.Add("taskOwnerLike", parameterToString(localVarOptionals.TaskOwnerLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskInvolvedUser.IsSet() {
		localVarQueryParams.Add("taskInvolvedUser", parameterToString(localVarOptionals.TaskInvolvedUser.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskCandidateGroup.IsSet() {
		localVarQueryParams.Add("taskCandidateGroup", parameterToString(localVarOptionals.TaskCandidateGroup.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskPriority.IsSet() {
		localVarQueryParams.Add("taskPriority", parameterToString(localVarOptionals.TaskPriority.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Finished.IsSet() {
		localVarQueryParams.Add("finished", parameterToString(localVarOptionals.Finished.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessFinished.IsSet() {
		localVarQueryParams.Add("processFinished", parameterToString(localVarOptionals.ProcessFinished.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ParentTaskId.IsSet() {
		localVarQueryParams.Add("parentTaskId", parameterToString(localVarOptionals.ParentTaskId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DueDate.IsSet() {
		localVarQueryParams.Add("dueDate", parameterToString(localVarOptionals.DueDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DueDateAfter.IsSet() {
		localVarQueryParams.Add("dueDateAfter", parameterToString(localVarOptionals.DueDateAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.DueDateBefore.IsSet() {
		localVarQueryParams.Add("dueDateBefore", parameterToString(localVarOptionals.DueDateBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutDueDate.IsSet() {
		localVarQueryParams.Add("withoutDueDate", parameterToString(localVarOptionals.WithoutDueDate.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskCompletedOn.IsSet() {
		localVarQueryParams.Add("taskCompletedOn", parameterToString(localVarOptionals.TaskCompletedOn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskCompletedAfter.IsSet() {
		localVarQueryParams.Add("taskCompletedAfter", parameterToString(localVarOptionals.TaskCompletedAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskCompletedBefore.IsSet() {
		localVarQueryParams.Add("taskCompletedBefore", parameterToString(localVarOptionals.TaskCompletedBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskCreatedOn.IsSet() {
		localVarQueryParams.Add("taskCreatedOn", parameterToString(localVarOptionals.TaskCreatedOn.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskCreatedBefore.IsSet() {
		localVarQueryParams.Add("taskCreatedBefore", parameterToString(localVarOptionals.TaskCreatedBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TaskCreatedAfter.IsSet() {
		localVarQueryParams.Add("taskCreatedAfter", parameterToString(localVarOptionals.TaskCreatedAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeTaskLocalVariables.IsSet() {
		localVarQueryParams.Add("includeTaskLocalVariables", parameterToString(localVarOptionals.IncludeTaskLocalVariables.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.IncludeProcessVariables.IsSet() {
		localVarQueryParams.Add("includeProcessVariables", parameterToString(localVarOptionals.IncludeProcessVariables.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeDefinitionId.IsSet() {
		localVarQueryParams.Add("scopeDefinitionId", parameterToString(localVarOptionals.ScopeDefinitionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeId.IsSet() {
		localVarQueryParams.Add("scopeId", parameterToString(localVarOptionals.ScopeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutScopeId.IsSet() {
		localVarQueryParams.Add("withoutScopeId", parameterToString(localVarOptionals.WithoutScopeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeType.IsSet() {
		localVarQueryParams.Add("scopeType", parameterToString(localVarOptionals.ScopeType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.PropagatedStageInstanceId.IsSet() {
		localVarQueryParams.Add("propagatedStageInstanceId", parameterToString(localVarOptionals.PropagatedStageInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenantId", parameterToString(localVarOptionals.TenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantIdLike.IsSet() {
		localVarQueryParams.Add("tenantIdLike", parameterToString(localVarOptionals.TenantIdLike.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutTenantId.IsSet() {
		localVarQueryParams.Add("withoutTenantId", parameterToString(localVarOptionals.WithoutTenantId.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseHistoricTaskInstanceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
HistoryTaskApiService Query for historic task instances
All supported JSON parameter fields allowed are exactly the same as the parameters found for getting a collection of historic task instances, but passed in as JSON-body arguments rather than URL-parameters to allow for more advanced querying and preventing errors with request-uri’s that are too long. On top of that, the query allows for filtering based on process variables. The taskVariables and processVariables properties are JSON-arrays containing objects with the format as described here.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *HistoryTaskApiQueryHistoricTaskInstanceOpts - Optional Parameters:
     * @param "Body" (optional.Interface of HistoricTaskInstanceQueryRequest) - 
@return DataResponseHistoricTaskInstanceResponse
*/

type HistoryTaskApiQueryHistoricTaskInstanceOpts struct {
    Body optional.Interface
}

func (a *HistoryTaskApiService) QueryHistoricTaskInstance(ctx context.Context, localVarOptionals *HistoryTaskApiQueryHistoricTaskInstanceOpts) (DataResponseHistoricTaskInstanceResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseHistoricTaskInstanceResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/query/historic-task-instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"*/*"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.Body.IsSet() {
		
		localVarOptionalBody:= localVarOptionals.Body.Value()
		localVarPostBody = &localVarOptionalBody
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseHistoricTaskInstanceResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
