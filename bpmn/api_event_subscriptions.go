
/*
 * Flowable REST API
 *
 * # flowable / flowəb(ə)l /    - a compact and highly efficient workflow and Business Process Management (BPM) platform for developers, system admins and business users.  - a lightning fast, tried and tested BPMN 2 process engine written in Java. It is Apache 2.0 licensed open source, with a committed community.  - can run embedded in a Java application, or as a service on a server, a cluster, and in the cloud. It integrates perfectly with Spring. With a rich Java and REST API, it is the ideal engine for orchestrating human or system activities.
 *
 * API version: v1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package bpmn

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type EventSubscriptionsApiService service
/*
EventSubscriptionsApiService Get a single event subscription
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param eventSubscriptionId
@return EventSubscriptionResponse
*/
func (a *EventSubscriptionsApiService) GetEventSubscription(ctx context.Context, eventSubscriptionId string) (EventSubscriptionResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue EventSubscriptionResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/event-subscriptions/{eventSubscriptionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"eventSubscriptionId"+"}", fmt.Sprintf("%v", eventSubscriptionId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v EventSubscriptionResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
/*
EventSubscriptionsApiService List of event subscriptions
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *EventSubscriptionsApiListEventSubscriptionsOpts - Optional Parameters:
     * @param "Id" (optional.String) -  Only return event subscriptions with the given id
     * @param "EventType" (optional.String) -  Only return event subscriptions with the given event type
     * @param "EventName" (optional.String) -  Only return event subscriptions with the given event name
     * @param "ActivityId" (optional.String) -  Only return event subscriptions with the given activity id
     * @param "ExecutionId" (optional.String) -  Only return event subscriptions with the given execution id
     * @param "ProcessInstanceId" (optional.String) -  Only return event subscriptions part of a process with the given id
     * @param "WithoutProcessInstanceId" (optional.Bool) -  Only return event subscriptions that have no process instance id
     * @param "ProcessDefinitionId" (optional.String) -  Only return event subscriptions with the given process definition id
     * @param "WithoutProcessDefinitionId" (optional.Bool) -  Only return event subscriptions that have no process definition id
     * @param "ScopeId" (optional.String) -  Only return event subscriptions part of a scope with the given id
     * @param "SubScopeId" (optional.String) -  Only return event subscriptions part of a sub scope with the given id
     * @param "WithoutScopeId" (optional.Bool) -  Only return event subscriptions that have no scope id
     * @param "ScopeDefinitionId" (optional.String) -  Only return event subscriptions with the given scope definition id
     * @param "WithoutScopeDefinitionId" (optional.Bool) -  Only return event subscriptions that have no scope definition id
     * @param "CreatedBefore" (optional.Time) -  Only return event subscriptions which are created before the given date.
     * @param "CreatedAfter" (optional.Time) -  Only return event subscriptions which are created after the given date.
     * @param "TenantId" (optional.String) -  Only return event subscriptions with the given tenant id.
     * @param "WithoutTenantId" (optional.Bool) -  Only return event subscriptions that have no tenant id
     * @param "Configuration" (optional.String) -  Only return event subscriptions with the given configuration value.
     * @param "WithoutConfiguration" (optional.Bool) -  Only return event subscriptions that have no configuration value
     * @param "Sort" (optional.String) -  Property to sort on, to be used together with the order.
@return DataResponseEventSubscriptionResponse
*/

type EventSubscriptionsApiListEventSubscriptionsOpts struct {
    Id optional.String
    EventType optional.String
    EventName optional.String
    ActivityId optional.String
    ExecutionId optional.String
    ProcessInstanceId optional.String
    WithoutProcessInstanceId optional.Bool
    ProcessDefinitionId optional.String
    WithoutProcessDefinitionId optional.Bool
    ScopeId optional.String
    SubScopeId optional.String
    WithoutScopeId optional.Bool
    ScopeDefinitionId optional.String
    WithoutScopeDefinitionId optional.Bool
    CreatedBefore optional.Time
    CreatedAfter optional.Time
    TenantId optional.String
    WithoutTenantId optional.Bool
    Configuration optional.String
    WithoutConfiguration optional.Bool
    Sort optional.String
}

func (a *EventSubscriptionsApiService) ListEventSubscriptions(ctx context.Context, localVarOptionals *EventSubscriptionsApiListEventSubscriptionsOpts) (DataResponseEventSubscriptionResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue DataResponseEventSubscriptionResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/runtime/event-subscriptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Id.IsSet() {
		localVarQueryParams.Add("id", parameterToString(localVarOptionals.Id.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventType.IsSet() {
		localVarQueryParams.Add("eventType", parameterToString(localVarOptionals.EventType.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.EventName.IsSet() {
		localVarQueryParams.Add("eventName", parameterToString(localVarOptionals.EventName.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ActivityId.IsSet() {
		localVarQueryParams.Add("activityId", parameterToString(localVarOptionals.ActivityId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ExecutionId.IsSet() {
		localVarQueryParams.Add("executionId", parameterToString(localVarOptionals.ExecutionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessInstanceId.IsSet() {
		localVarQueryParams.Add("processInstanceId", parameterToString(localVarOptionals.ProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutProcessInstanceId.IsSet() {
		localVarQueryParams.Add("withoutProcessInstanceId", parameterToString(localVarOptionals.WithoutProcessInstanceId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ProcessDefinitionId.IsSet() {
		localVarQueryParams.Add("processDefinitionId", parameterToString(localVarOptionals.ProcessDefinitionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutProcessDefinitionId.IsSet() {
		localVarQueryParams.Add("withoutProcessDefinitionId", parameterToString(localVarOptionals.WithoutProcessDefinitionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeId.IsSet() {
		localVarQueryParams.Add("scopeId", parameterToString(localVarOptionals.ScopeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.SubScopeId.IsSet() {
		localVarQueryParams.Add("subScopeId", parameterToString(localVarOptionals.SubScopeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutScopeId.IsSet() {
		localVarQueryParams.Add("withoutScopeId", parameterToString(localVarOptionals.WithoutScopeId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ScopeDefinitionId.IsSet() {
		localVarQueryParams.Add("scopeDefinitionId", parameterToString(localVarOptionals.ScopeDefinitionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutScopeDefinitionId.IsSet() {
		localVarQueryParams.Add("withoutScopeDefinitionId", parameterToString(localVarOptionals.WithoutScopeDefinitionId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedBefore.IsSet() {
		localVarQueryParams.Add("createdBefore", parameterToString(localVarOptionals.CreatedBefore.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.CreatedAfter.IsSet() {
		localVarQueryParams.Add("createdAfter", parameterToString(localVarOptionals.CreatedAfter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.TenantId.IsSet() {
		localVarQueryParams.Add("tenantId", parameterToString(localVarOptionals.TenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutTenantId.IsSet() {
		localVarQueryParams.Add("withoutTenantId", parameterToString(localVarOptionals.WithoutTenantId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Configuration.IsSet() {
		localVarQueryParams.Add("configuration", parameterToString(localVarOptionals.Configuration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.WithoutConfiguration.IsSet() {
		localVarQueryParams.Add("withoutConfiguration", parameterToString(localVarOptionals.WithoutConfiguration.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Sort.IsSet() {
		localVarQueryParams.Add("sort", parameterToString(localVarOptionals.Sort.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		if localVarHttpResponse.StatusCode == 200 {
			var v DataResponseEventSubscriptionResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
